# RESW
$web-only$
While `ress` and `ressa` consume text and generate data structures, `resw` is going to consume data structures and write out text. This means it can do the heavy lifting when solving the problem our debug logging project left us with. However instead of just sweeping that under the rug, we are going to go over how `resw` works. Because the nature of JavaScript, `resw` makes some style decisions that might not work for everyone, by going over the project in detail the hope is that other's will feel enabled to either contribute a configuration option into `resw` or even implement their own project that consumes `ressa`'s AST and generates text.

If you are just interested in seeing how we are going to finish the project from the last chapter, feel free to skip this chapter.

Similar to the structure of `ressa`, `resw` exposes a struct that will keep track of the context for us called `Writer`. There are 2 methods for constructing a `Writer`, the first is the `::new` method the second is the `::builder` method that utilizes the _builder_ pattern to customize some options. Those options include
 - New line character (default `\n`)
 - Quote (default to use origin quotation mark)
   - Setting this to any value will force all of the string literals in the provided JavaScript to be re-written with the provided quotes
 - Indent (default 4 spaces)

Either method you are going to need to provide the destination, this can be anything that implements the `std::io::Write` trait. For testing purposes the crate provides an implementor of `Write` in `WriteString`, we are not going to cover that here but a more detailed explanation can be found in the [appendix](./a.appendix/string.writer.md).

Once a `Writer` is constructed, it provides an API surface that should cover most of the `ressa` AST. The primary entry-point for most uses is either `write_program` or `write_part`. For the most part, the primary role of the writer is going to be incrementally move down the AST until we find something that we are confident in exactly what to write. Let's take the following js as an example.

```js
function Thing(stuff) {
    this.stuff = stuff;
}
let thing = new Thing('argument');
```
If we run that that through the `ressa::Parser`, we would see the following AST.

```ron
Decl(
    Function(
        Function {
            id: Some(
                "Thing"
            ),
            params: [
                Pattern(
                    Identifier(
                        "stuff"
                    )
                )
            ],
            body: [
                Statement(
                    Expr(
                        Assignment(
                            AssignmentExpression {
                                operator: Equal,
                                left: Expr(
                                    Member(
                                        MemberExpression {
                                            object: ThisExpression,
                                            property: Ident(
                                                "stuff"
                                            ),
                                            computed: false
                                        }
                                    )
                                ),
                                right: Ident(
                                    "stuff"
                                )
                            }
                        )
                    )
                )
            ],
            generator: false,
            is_async: false
        }
    )
)
Decl(
    Variable(
        Let,
        [
            VariableDecl {
                id: Identifier(
                    "thing"
                ),
                init: Some(
                    New(
                        NewExpression {
                            callee: Ident(
                                "Thing"
                            ),
                            arguments: [
                                Literal(
                                    String(
                                        "\'argument\'"
                                    )
                                )
                            ]
                        }
                    )
                )
            }
        ]
    )
)
```

With that, let's how `resw` would generate the text to represent our AST. First we would enter at `write_part`. 

```rust
pub fn write_part(&mut self, part: &ProgramPart) -> Res {
    trace!("write_part: {:#?}", part);
    self.at_top_level = true;
    self._write_part(part)?;
    self.write_new_line()?;
    Ok(())
}
```

Interestingly enough, `write_part` is really more concerned with maintaining a context flag for if we are at the top level or not, this becomes important when dealing with top level expressions, though we won't cover that here. Almost all of the work is going to be passed off to an internal private function `_write_part`. 

```rust
fn _write_part(&mut self, part: &ProgramPart) -> Res {
    trace!("_write_part");
    self.write_leading_whitespace()?;
    match part {
        ProgramPart::Decl(decl) => self.write_decl(decl)?,
        ProgramPart::Directive(dir) => self.write_directive(dir)?,
        ProgramPart::Statement(stmt) => self.write_stmt(stmt)?,
    }
    Ok(())
}
```

The first thing we want to do is make sure that any leading whitespace is included with `write_leading_whitespace`.

```rust
pub fn write_leading_whitespace(&mut self) -> Res {
    trace!("write_leading_whitespace");
    self.write(&self.indent.repeat(self.current_indent))?;
    Ok(())
}
```
This is achieved by looking at the `current_indent` and writing the `indent` string to the destination repeated the for our current indent level. Internally the `write` method just writes a single `&str` to the destination. After we write our leading whitespace, we can start to descend the AST, we do that by matching on the part. You can see that there is a branch for each of the possible enum variants, looking back at the ast, we know the next step would be to head to `write_decl`.

```rust
pub fn write_decl(&mut self, decl: &Declaration) -> Res {
    trace!("write_decl");
    match decl {
        Declaration::Variable(ref kind, ref decls) => self.write_variable_decls(kind, decls),
        Declaration::Class(ref class) => {
            self.at_top_level = false;
            self.write_class(class)?;
            self.write_new_line()
        },
        Declaration::Function(ref func) => {
            self.at_top_level = false;
            self.write_function(func)?;
            self.write_new_line()
        },
        Declaration::Export(ref exp) => self.write_export_decl(exp),
        Declaration::Import(ref imp) => self.write_import_decl(imp),
    }?;
    Ok(())
}
```
Moving further down we simply match on the the declaration handling each variant as needed. For our example we would move into the `Declaration:Function` branch, The first step in that branch is to set the context flag `at_top_level` to `false` and then move into the `write_function` method.

```rust
pub fn write_function(&mut self, func: &Function) -> Res {
    trace!("write_function");
    if func.is_async {
        self.write("async ")?;
    }
    self.write("function")?;
    if let Some(ref id) = func.id {
        self.write(" ")?;
        if func.generator {
            self.write("*")?;
        }
        self.write(id)?;
    } else if func.generator {
        self.write("*")?;
    }
    self.write_function_args(&func.params)?;
    self.write_function_body(&func.body)
}
```
Here we are going to actually start writing some information out to our destination. First is we check the flag on `Function` to see if we need to write the `async` keyword, next we write the keyword `function` followed by a check to see if the id is `Some`. If so we need to check the flag on `Function` to see if that function is a generator, if it is we need to add a `*` before the id, and Lastly we write the `id`

Now that we have gotten though that we can start to look at the parameters and body. First we are going to pass off the parameters to `write_function_args`.

```rust
/// Write the arguments of a function or method definition
/// ```js
/// function(arg1, arg2) {
/// }
/// ```
pub fn write_function_args(&mut self, args: &[FunctionArg]) -> Res {
    trace!("write_function_args");
    self.write("(")?;
    let mut after_first = false;
    for ref arg in args {
        if after_first {
            self.write(", ")?;
        } else {
            after_first = true;
        }
        self.write_function_arg(arg)?;
    }
    self.write(") ")?;
    Ok(())
}
```
The first step here is to write the open parenthesis, next we are going to use a flag `after_first` to help with handing if a comma should be written before the argument. This is the first place that we have seen where `resw` is making a style choice, all function parameters will not include a trailing comma. Ideally style choices will be configurable in the future but currently this one is not. Now that we have handled the comma situation we can pass the argument off to `write_function_arg`.

```rust
/// Write a single function arg
pub fn write_function_arg(&mut self, arg: &FunctionArg) -> Res {
    trace!("write_function_arg");
    match arg {
        FunctionArg::Expr(ref ex) => self.write_expr(ex)?,
        FunctionArg::Pattern(ref pa) => self.write_pattern(pa)?,
    }
    Ok(())
}
```

Here we see another function that simple move us further down the AST. Function arguments can be either expressions or patterns so we need to handle both. For our example we are going to head down the `Pattern` branch with `write_patern`.

```rust
/// Write the contents of a pattern
pub fn write_pattern(&mut self, pattern: &Pattern) -> Res {
    trace!("write_pattern");
    match pattern {
        Pattern::Identifier(ref i) => self.write(i),
        Pattern::Object(ref o) => self.write_object_pattern(o),
        Pattern::Array(ref a) => self.write_array_pattern(a),
        Pattern::RestElement(ref r) => self.write_rest_element(r),
        Pattern::Assignment(ref a) => self.write_assignment_pattern(a),
    }
}
```
Most of the options here are simply going to continue branching down our AST, however for our example we are going to head down the first match arm with `Pattern::Identifer` and just write that string out to our destination.

Moving back up we only had one parameter for our function signature so we finish out `write_function_args` with a closing parenthesis. That then leads us to `write_function_body`.

```rust
/// Write the block statement that makes up a function's body
pub fn write_function_body(&mut self, body: &FunctionBody) -> Res {
    trace!("write_function_body");
    if body.len() == 0 {
        self.write("{ ")?;
    } else {
        self.write_open_brace()?;
        self.write_new_line()?;
    }
    for ref part in body {
        self._write_part(part)?;
    }
    if body.len() == 0 {
        self.write("}")?;
    } else {
        self.write_close_brace()?;
    }
    Ok(())
}
```
The first thing we need to do is take a look at the `&FunctionBody` which is a type alias for `Vec<ProgramPart>`. We check to see if this function has any body, if not we just write a single open curly brace, if it does we want to write the curly brace using `write_open_brace`, this is a convenience method for writing the character and also incrementing the `current_indent`, lastly we write a new line. Now we loop over each of the `ProgramPart`s in `body` and pass that off to `_write_body`. For our example there is only going to be one part. This part is a `ProgramPart::Statement` which would be handled by `write_stmt`.

```rust
/// Attempts to write the contents of a `Statement`
pub fn write_stmt(&mut self, stmt: &Statement) -> Res {
    trace!("write_stmt");
    let mut semi = true;
    let mut new_line = true;
    let cached_state = self.at_top_level;
    match stmt {
        Statement::Empty => (),
        Statement::Debugger => self.write_debugger_stmt()?,
        Statement::Expr(ref stmt) => self.write_expr(stmt)?,
        Statement::Block(ref stmt) => {
            self.at_top_level = false;
            self.write_block_stmt(stmt)?;
            semi = false;
            new_line = false;
            self.at_top_level = cached_state;
        },
        Statement::With(ref stmt) => {
            self.write_with_stmt(stmt)?;
            semi = false;
        },
        Statement::Return(ref stmt) => self.write_return_stmt(stmt)?,
        Statement::Labeled(ref stmt) => {
            self.write_labeled_stmt(stmt)?;
            semi = false;
        },
        Statement::Break(ref stmt) => self.write_break_stmt(stmt)?,
        Statement::Continue(ref stmt) => self.write_continue_stmt(stmt)?,
        Statement::If(ref stmt) => {
            self.write_if_stmt(stmt)?;
            semi = false;
        },
        Statement::Switch(ref stmt) => {
            self.at_top_level = false;
            self.write_switch_stmt(stmt)?;
            semi = false;
            self.at_top_level = cached_state;
        },
        Statement::Throw(ref stmt) => self.write_throw_stmt(stmt)?,
        Statement::Try(ref stmt) => {
            self.write_try_stmt(stmt)?;
            semi = false;
        },
        Statement::While(ref stmt) => {
            new_line = self.write_while_stmt(stmt)?;
            semi = false;
        },
        Statement::DoWhile(ref stmt) => self.write_do_while_stmt(stmt)?,
        Statement::For(ref stmt) => {
            self.at_top_level = false;
            new_line = self.write_for_stmt(stmt)?;
            semi = false;
            self.at_top_level = cached_state;
        },
        Statement::ForIn(ref stmt) => {
            self.at_top_level = false;
            new_line = self.write_for_in_stmt(stmt)?;
            semi = false;
            self.at_top_level = cached_state;
        },
        Statement::ForOf(ref stmt) => {
            self.at_top_level = false;
            new_line = self.write_for_of_stmt(stmt)?;
            semi = false;
            self.at_top_level = cached_state;
        },
        Statement::Var(ref stmt) => self.write_var_stmt(stmt)?,
    };
    if semi {
        self.write_empty_stmt()?;
    }
    if new_line {
        self.write_new_line()?;
    }
    Ok(())
}
```
That is a pretty big match statement! Looking at our example, we would enter the `Statement::Expr` branch which passes all its work off to `write_expr`.

```rust
pub fn write_expr(&mut self, expr: &Expression) -> Res {
    trace!("write_expr");
    let cached_state = self.at_top_level;
    match expr {
        Expression::Literal(ref expr) => self.write_literal(expr)?,
        Expression::ThisExpression => self.write_this_expr()?,
        Expression::SuperExpression => self.write_super_expr()?,
        Expression::Array(ref expr) => self.write_array_expr(expr)?,
        Expression::Object(ref expr) => self.write_object_expr(expr)?,
        Expression::Function(ref expr) => {
            self.at_top_level = false;
            self.write_function(expr)?;
            self.at_top_level = cached_state;
        },
        Expression::Unary(ref expr) => self.write_unary_expr(expr)?,
        Expression::Update(ref expr) => self.write_update_expr(expr)?,
        Expression::Binary(ref expr) => self.write_binary_expr(expr)?,
        Expression::Assignment(ref expr) => self.write_assignment_expr(expr)?,
        Expression::Logical(ref expr) => self.write_logical_expr(expr)?,
        Expression::Member(ref expr) => self.write_member_expr(expr)?,
        Expression::Conditional(ref expr) => self.write_conditional_expr(expr)?,
        Expression::Call(ref expr) => self.write_call_expr(expr)?,
        Expression::New(ref expr) => self.write_new_expr(expr)?,
        Expression::Sequence(ref expr) => self.write_sequence_expr(expr)?,
        Expression::Spread(ref expr) => self.write_spread_expr(expr)?,
        Expression::ArrowFunction(ref expr) => {
            self.at_top_level = false;
            self.write_arrow_function_expr(expr)?;
            self.at_top_level = cached_state;
        },
        Expression::Yield(ref expr) => self.write_yield_expr(expr)?,
        Expression::Class(ref expr) => {
            self.at_top_level = false;
            self.write_class(expr)?;
            self.at_top_level = cached_state;
        },
        Expression::MetaProperty(ref expr) => self.write_meta_property(expr)?,
        Expression::Await(ref expr) => self.write_await_expr(expr)?,
        Expression::Ident(ref expr) => self.write_ident(expr)?,
        Expression::TaggedTemplate(ref expr) => self.write_tagged_template(expr)?,
        _ => unreachable!(),
    }
    Ok(())
}
```
The first step here is to keep a copy of the previous `at_top_level` flag so that we can revert back to it when writing some of the options. next we enter another very large match statement. Our example would take the `Expression::Assignment` arm, passing further work off to `write_assignment_expr`.

```rust
/// Write an assignment expression
/// ```js
/// a = b
/// b += 8
/// q **= 100
/// ```
pub fn write_assignment_expr(&mut self, assignment: &AssignmentExpression) -> Res {
    trace!("write_assignment_expr");
    match &assignment.left {
        AssignmentLeft::Expr(ref e) => self.write_expr(e)?,
        AssignmentLeft::Pattern(ref p) => self.write_pattern(p)?,
    }
    self.write(" ")?;
    self.write_assignment_operator(&assignment.operator)?;
    self.write(" ")?;
    self.write_expr(&assignment.right)?;
    Ok(())
}
```
Here we are first testing the `assignment.left` property since it can be either an `Expression` or a `Pattern`, our example would take us back to the `write_expr` method. This time we would pass into the `Expression::Member` arm which passes its work off to `write_member_expr`.

```rust
/// Writes a member expression
/// ```js
/// console.log
/// console['log']
/// ```
pub fn write_member_expr(&mut self, member: &MemberExpression) -> Res {
    trace!("write_member_expr");
    if let Expression::Assignment(_) = &*member.object {
        self.write_wrapped_expr(&member.object)?;
    } else {
        self.write_expr(&member.object)?;
    };
    if member.computed {
        self.write("[")?;
    } else {
        self.write(".")?;
    }
    self.write_expr(&member.property)?;
    if member.computed {
        self.write("]")?;
    }
    Ok(())
}
```
Here we first check to see if the `object` property is itself an `Expression::Assignment`, if so we need to wrap that in parentheses, for us though we just want to pass that again to `write_expr`. This time though there we are going to end up at `Expression::ThisExpression` which just writes out the literal word `this`. Next we are going to look at the flag on `MemberExpression` "computed" to see if this was written originally with the bracket notation or the dot notation, writing the appropriate character. Next we are again going to pass some work back to `write_expr`, this time with the `property` property. This would end on the branch for `Expression::Ident` which just writes that value to the destination. If the member expression was computed we would need to write the `]` but for our example it is not. 

At this point we are back up at `write_assignment_expr` where we are going to write a single space and then pass the `assignment.operator` off to `write_assignment_operator`. 

```rust
pub fn write_assignment_operator(&mut self, op: &AssignmentOperator) -> Res {
    let s = match op {
        AssignmentOperator::AndEqual => "&=",
        AssignmentOperator::DivEqual => "/=",
        AssignmentOperator::Equal => "=",
        AssignmentOperator::LeftShiftEqual => "<<=",
        AssignmentOperator::MinusEqual => "-=",
        AssignmentOperator::ModEqual => "%=",
        AssignmentOperator::OrEqual => "|=",
        AssignmentOperator::PlusEqual => "+=",
        AssignmentOperator::PowerOfEqual => "**=",
        AssignmentOperator::RightShiftEqual => ">>=",
        AssignmentOperator::TimesEqual => "*=",
        AssignmentOperator::UnsignedRightShiftEqual => ">>>=",
        AssignmentOperator::XOrEqual => "^=",
    };
    self.write(s)?;
    Ok(())
}
```
This is a relatively straight forward process of looking at which operator was provided and then writing out the text that represents that operator. For our example it would be `=`, we then need to write a single space. The last step in `write_assignment_expr` is to handle the `assignment.right` which is also an `Expression` so we pass that off to `write_expr`. Our example will head to the `Expression::Ident` match arm and then just write to the destination. With that we have now reached the last step in `write_function_body` which is to `write_close_brace` similar to `write_open_brace` here we are decrementing the `current_indent` context property. That also brings us to the end of `write_function`, `write_decl`, and `_write_part`. The last thing we do in `write_part` is to add a trailing new line, another style choice.

As our example continues we would then start again at `write_part` with the next part. This is going to move though `_write_part` the same way our last part did, however when we get to `write_decl` we have a new branch to head down. This is the `Decl::Variable` arm which passes its work off to `write_variable_decls`.

```rust
/// Attempt to write a `Declaration::Variable`'s contents to the `impl Write`
/// ```js
/// let a, b, c, d, e = "thing";
/// const f = "stuff";
/// var g, h, i, j = "places";
/// ```
pub fn write_variable_decls(&mut self, kind: &VariableKind, decls: &[VariableDecl]) -> Res {
    trace!("write_variable_decls");
    self.write_variable_kind(kind)?;
    let mut after_first = false;
    let mut write_semi = true;
    for decl in decls {
        if after_first {
            self.write(", ")?;
        } else {
            after_first = true;
        }
        write_semi = self.write_variable_decl(decl)?;
    }
    if write_semi {
        self.write_empty_stmt()?;
    }
    self.write_new_line()
}
```
As you might expect the first thing we want to do is to write the variable kind. We pass off the `kind` variable to `write_variable_kind`.
```rust
/// Attempts to write the variable keyword (`var`/`let`/`const`)
pub fn write_variable_kind(&mut self, kind: &VariableKind) -> Res {
    trace!("write_variable_kind");
    let s = match kind {
        VariableKind::Const => "const ",
        VariableKind::Let => "let ",
        VariableKind::Var => "var ",
    };
    self.write(s)
}
```
Similar to our examination of `write_assignment_operator` we are going to simply look at which keyword was used and then write that out, with a trailing space. 

Next we need to keep track of two flags `after_first` and `write_semi`, the first of which should be familiar from `write_function_args` the second is to help us deal with the end of a variable declaration. In our loop, we pass of each of the declarations to `write_variable_decl`.
```rust
pub fn write_variable_decl(&mut self, decl: &VariableDecl) -> Result<bool, IoError> {
    trace!("write_variable_decl");
    self.write_pattern(&decl.id)?;
    let mut ret = true;
    if let Some(ref init) = decl.init {
        self.write(" = ")?;
        self.write_expr(init)?;
        ret = match init {
            Expression::Function(_)
            | Expression::Class(_) => false,
            _ => true,
        }
    }
    Ok(ret)
}
```
Here we first write out the id of this variable by passing it off to `write_pattern`. 
```rust
pub fn write_pattern(&mut self, pattern: &Pattern) -> Res {
    trace!("write_pattern");
    match pattern {
        Pattern::Identifier(ref i) => self.write(i),
        Pattern::Object(ref o) => self.write_object_pattern(o),
        Pattern::Array(ref a) => self.write_array_pattern(a),
        Pattern::RestElement(ref r) => self.write_rest_element(r),
        Pattern::Assignment(ref a) => self.write_assignment_pattern(a),
    }
}
```
Thankfully our example is pretty simple so we are again going to take that first branch for `Pattern::Ident` and write the identifer to our destination. After that we want to check if this variable is initialized, ours is, and if so we would write the " = " and then write the expression by passing that off to `write_expr`. For this pass through `write_expr` we are going to travel down the `Expression::New` arm which passes its work off to `write_new_expr`.
```rust
pub fn write_new_expr(&mut self, new: &NewExpression) -> Res {
    trace!("write_new_expr");
    self.write("new ")?;
    self.write_expr(&new.callee)?;
    self.write("(")?;
    self.write_sequence_expr(&new.arguments)?;
    self.write(")")?;
    Ok(())
}
```
At this point we want to first write the `new` keyword followed by a space. Next we want to write out what the `new.callee` is which would again bring us to `write_expr`. Our example would travel to the `Expression::Ident` arm which just writes that out. Next we need to write an open parenthesis followed by the provided arguments. This time we are going to use the `write_sequence_expr` method to do that. 
```rust
pub fn write_sequence_expr(&mut self, sequence: &[Expression]) -> Res {
    trace!("write_sequence_expr");
    let mut after_first = false;
    for ref e in sequence {
        if after_first {
            self.write(", ")?;
        }
        self.write_expr(e)?;
        after_first = true;
    }
    Ok(())
}
```
At this point the structure of this function's body should look familiar, we are going to loop over the provide expressions and write them out with a comma and space before all but the first one. For our example we are going only hit this once so no comma, then we are going to pass that off to `write_expr`. This time as we pass through the match in `write_expr` we are going to hit the `Expression::Literal` arm which passes its work off to `write_literal`.

```rust
pub fn write_literal(&mut self, lit: &Literal) -> Res {
    trace!("write_literal");
    match lit {
        Literal::Boolean(b) => self.write_bool(*b),
        Literal::Null => self.write("null"),
        Literal::Number(n) => self.write(&n),
        Literal::String(s) => self.write_string(s),
        Literal::RegEx(r) => self.write_regex(r),
        Literal::Template(t) => self.write_template(t),
    }
}
```
Here we see another match statement, our example will take us down the `Literal::String` arm which passes off work to `write_string`. You may be wondering why that is, since writing strings is all we have really been doing. The answer is that this is one of the few style preferences that is currently configurable as you'll see.

```rust
pub fn write_string(&mut self, s: &str) -> Res {
    trace!("write_string");
    if let Some(c) = self.quote {
        self.re_write_string(s, c)?;
    } else {
        self.write(s)?;
    }
    Ok(())
}
```
As you can see we first check to see if the `self.quote` property has been set, this would indicate that the user has a quote preference. If it is set then we want to re-write the string to use this quote, this involves re-writing any internal escaped quotes for the old quote and escaping the new quote that might appear in the contents. If that property is `None` then we would just write it out normally as the `ressa::node::Literal::String` preserves the original quotation mark.

After that we are again back at `write_new_expr` where the last thing to do is write the closing parenthesis. After which we can move back to `write_variable_decl`, the next step for this function is to determine the value of `ret` which will be true unless the `init` is an `Expression::Function` or `Expression::Class`. When we move up again to the `write_variable_decls` we see that `write_semi` gets overwritten with this value at the bottom of each loop. This means that we would only not write a semi-colon if the last declaration was initialized to a function or class. Here examples of each option.
```js
// semi-colon
let x, y, b = 'things';
// no semi-colon
let x, y, b = function() { 
    return 'things';
}
```
This brings us to the bottom of `write_decl`, `_write_part`, and `write_part`, it also brings us to the end of our example JavaScript. While we didn't touch every part of how `resw` works, there is a lot of surface area to cover. For more information you can check out the [`ressa` docs](https://docs.rs/ressa/) and the [`resw` docs](https://docs.rs/resw/). 

Up next we are going to see how you would use `resw` to complete our debug log helper.

$web-only-end$

$slides-only$
- `Writer` takes `ProgramPart`s
- Somewhat Configurable
- Writes to `impl Write`
$slides-only$