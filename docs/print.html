<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Build JavaScript Development Tools with Rust</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="01.overview/1.html">An Overview</a></li><li><a href="02.ress/1.html"><strong aria-hidden="true">1.</strong> RESS</a></li><li><ol class="section"><li><a href="02.ress/2.html"><strong aria-hidden="true">1.1.</strong> Building a Linter</a></li></ol></li><li><a href="03.ressa/1.html"><strong aria-hidden="true">2.</strong> RESSA</a></li><li><ol class="section"><li><a href="03.ressa/2.html"><strong aria-hidden="true">2.1.</strong> Building a Debug Helper</a></li></ol></li><li><a href="04.resw/1.html"><strong aria-hidden="true">3.</strong> RESW</a></li><li><ol class="section"><li><a href="04.resw/2.html"><strong aria-hidden="true">3.1.</strong> Finishing a Debug Helper</a></li></ol></li><li><a href="05.conclusion/1.html"><strong aria-hidden="true">4.</strong> Conclusion</a></li><li><a href="a.appendix/overview.html"><strong aria-hidden="true">5.</strong> Appendix</a></li><li><ol class="section"><li><a href="a.appendix/tokens.html"><strong aria-hidden="true">5.1.</strong> Tokens</a></li><li><a href="a.appendix/ie-8-banned.html"><strong aria-hidden="true">5.2.</strong> Banned Tokens</a></li><li><a href="a.appendix/ast.html"><strong aria-hidden="true">5.3.</strong> AST</a></li><li><a href="a.appendix/string.writer.html"><strong aria-hidden="true">5.4.</strong> StringWriter</a></li><li><a href="a.appendix/projects.html"><strong aria-hidden="true">5.5.</strong> Projects</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Build JavaScript Development Tools with Rust</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>.presentation-only.not-presenting{display:none}.article-content.presenting{display:none}
</style>
<h1 style="text-align: center;margin: 0;">An Overview</h1>
<div style="margin: auto;width:100%;max-width:500px;max-height:500px;" title="This logo is a mash up of the Rust and EcmaInternational logos, neither">
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg xmlns="http://www.w3.org/2000/svg" width="100%" viewBox="0 0 135 135" xml:space="preserve">
    <defs>
    </defs>
    <g transform="scale(0.2)">
        <path style="fill:#ee8421;fill-opacity:1;fill-rule:nonzero;stroke:none;)" d="m 245,80
           c -21.984,15.34
            -49.589,36.21
            -70.05,56.04
            -29.344,26.62
            -53.328,59.08
            -70.086,94.86
            13.027,-37.43
            33.894,-73.61
            64.707,-102.99
            23.789,-19.45
            49.277,-35.2
            75.429,-47.91
           z
           m 283.508,464.34
           c -23.019,34.91
             -67.136,55.51
             -109.523,68.96
             -125.883,49.63
             -305.324,-45.01
             -331.926,-208.18
             -1.707,-7.6
             -4.519,-24.99
             -3.836,-38
             11.387,99.8
             71.883,187.38
             154.07,224.66
             81.012,38.93
             176.68,32.05
             242.235,-14.05
             3.383,-2.65
             6.758,-5.5
             9.965,-8.31
             -11.461,5.91
             -23.555,10.91
             -36.059,14.92
             -44.34,21.37
             -97.086,29.84
             -149.531,18.59
             -103.215,-16.18
             -196.793,-110.16
             -212.945,-227.39
             -1.309,-7.58
             -2.188,-15.32
             -2.731,-23.08
             -3.105,2.25
             -5.004,7.76
             -5.004,14.66
             -1.734,-8
             -1.734,-15.99
             -1.348,-24.08
             -1.121,-37.5
             7.329,-76.14
             22.989,-112.14
             -6.078,18.59
             -9.883,37.37
             -11.965,56.12
             7.461,-36.53
             22.832,-71.65
             46.23,-99.9
             15.383,-15.82
             32.606,-50.56
             53.434,-61.71
             79.211,-62.83
             199.398,-84.16
             280.52,-37.94
             11.105,2.99
             22.175,6.2
             32.171,11.99
             -12.961,-4.3
             -27.511,-7.17
             -39.144,-11.25
            l -3.879,-0.04
            c -3.352,-1.91
            -5.02,-2.82
            -6.731,-3.75
            -59.89,-7.56
            -182.539,-20.84
            -258.125,42.87
            -21.46,15.4
            -38.074,35.66
            -53.644,56.44
            7.957,-5.44
            20.773,-12.8
            28.504,-20.94
            38.078,-38.03
            90.387,-72.42
            141.32,-76.53
            -23.488,9.59
            -43.664,21
            -65.879,34.45
            -11.504,5.3
            -29.933,8.35
            -38.285,18.09
            -47.598,40.62
            -88.266,82.24
            -95.582,144.73
            -1.113,6.13
            2.852,10.97
            0.867,16.56
            12.004,-69.19
            55.352,-120.37
            109.813,-161.18
            7.39,-8.67
            15.73,-12.25
            23.187,-18.2
            9.52,-3.42
            17.965,-6.71
            24.965,-10.4
            80.859,-30.22
            95.289,2.93
            167.797,3.98
            -32.703,-8.29
            -88.605,-23.58
            -116.895,-25.42
            50.868,-10.48
            146.872,15.41
            190.723,48.05
            54.508,37.2
            43.57,38.87
            71.719,86.45
            2.461,3.89
            4.859,12.75
            6.883,23.48
            17.101,32.93
            26.902,70.31
            26.902,109.99
            0,76.13
            -35.746,143.81
            -91.262,187.5
            z M 194.215,3949.4
            c -4.785,30.86
            -6.207,62.4
            0.449,93.73
            -0.633,-6.18
            -1.148,-11.15
            -0.851,-13.52
            -3.008,-37.79
            -0.102,-68.66
            3.359,-88.72
            -0.867,2.67
            -1.844,5.43
            -2.957,8.51
            1.332,-5.95
            2.926,-11.87
            4.75,-17.61
            3.015,-14.15
            5.801,-19.79
            5.004,-14.56
            24.176,-63.35
            75.176,-112.26
            131.734,-135.35
            -55.262,6.87
            -128.461,82.28
            -141.488,167.52
            z m 161.144,272.12
            c -46.211,-9.64
            -91.421,-35.17
            -124.617,-80.41
            22.246,28.19
            48.785,43.34
            74.684,52.44
            -2.336,-1.71
            -4.61,-3.41
            -6.856,-5.17
            -20.207,-11.98
            -39.179,-26.38
            -56.156,-44.42
            -4.582,-5.87
            -6.672,-13.02
            -10.949,-18.21
            l -9.059,-13.66
            c -12.011,-11.35
            -19.187,-24.94
            -26.996,-39.34
            -33.906,-74.8
            -29.828,-167.94
            16.703,-246.25
            -84.133,116.5
            -50.945,282.96
            48.625,356.67
            41.434,32.69
            89.453,48.65
            136.606,51.25
            -14.524,-2.99
            -28.535,-7.41
            -41.985,-12.9
            z m 152.844,-460.93
            c -7.836,-1.39
            4.27,2
            39.504,22.81
            3.059,1.76
            6.375,3.89
            9.836,6.16
            13.734,7.28
            26.727,15.93
            38.742,25.74
            -34.687,-33.57
            -77.305,-54.88
            -88.082,-54.71" />
    </g>
    <g transform="scale(0.89)">
        <path fill="white" d="m124.68 78.95a44.63 44.63 0 0 1 -44.63 44.63 44.63 44.63 0 0 1 -44.63-44.63 44.63 44.63 0 0 1 44.63-44.63 44.63 44.63 0 0 1 44.63 44.63zm-.84-4.31 6.96 4.31-6.96 4.31 5.98 5.59-7.66 2.87 4.78 6.65-8.09 1.32 3.4 7.46-8.19-.29 1.88 7.98-7.98-1.88.29 8.19-7.46-3.4-1.32 8.09-6.65-4.78-2.87 7.66-5.59-5.98-4.31 6.96-4.31-6.96-5.59 5.98-2.87-7.66-6.65 4.78-1.32-8.09-7.46 3.4.29-8.19-7.98 1.88 1.88-7.98-8.19.29 3.4-7.46-8.09-1.32 4.78-6.65-7.66-2.87 5.98-5.59-6.96-4.31 6.96-4.31-5.98-5.59 7.66-2.87-4.78-6.65 8.09-1.32-3.4-7.46 8.19.29-1.88-7.98 7.98 1.88-.29-8.19 7.46 3.4 1.32-8.09 6.65 4.78 2.87-7.66 5.59 5.98 4.31-6.96 4.31 6.96 5.59-5.98 2.87 7.66 6.65-4.78 1.32 8.09 7.46-3.4-.29 8.19 7.98-1.88-1.88 7.98 8.19-.29-3.4 7.46 8.09 1.32-4.78 6.65 7.66 2.87z" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round" stroke-width="3"/>
        <path fill="white" d="m80.05 31.68
        c-26.06 0-47.27 21.22-47.27 47.27
        s21.22 47.27 47.27 47.27 47.27-21.22 47.27-47.27-21.22-47.27-47.27-47.27z
        m-.07 4.2
        a3.1 3.11 0 0 1 3.02 3.11 3.11 3.11 0 0 1 -6.22 0 3.11 3.11 0 0 1 3.2-3.11z
        m7.12 5.12
        a38.27 38.27 0 0 1 26.2 18.66l-3.67 8.28
        c-.63 1.43.02 3.11 1.44 3.75l7.06 3.13a38.27 38.27 0 0 1  .08 6.64h-3.93
        c-.39 0-.55.26-.55.64
        v1.8
        c0 4.24-2.39 5.17-4.49 5.4-2 .23-4.21-.84-4.49-2.06-1.18-6.63-3.14-8.04-6.24-10.49 3.85-2.44 7.85-6.05 7.85-10.87 0-5.21-3.57-8.49-6-10.1-3.42-2.25-7.2-2.7-8.22-2.7
        h-40.6a38.27 38.27 0 0 1 21.41-12.08l4.79 5.02c1.08 1.13 2.87 1.18 4 .09z
        m-44.2 23.02
        a3.11 3.11 0 0 1 3.02 3.11 3.11 3.11 0 0 1 -6.22 0 3.11 3.11 0 0 1 3.2-3.11z
        m74.15.14a3.11 3.11 0 0 1 3.02 3.11 3.11 3.11 0 0 1 -6.22 0 3.11 3.11 0 0 1 3.2-3.11z
        m-68.29.5h5.42
        v24.44h-10.94
        a38.27 38.27 0 0 1 -1.24-14.61l6.7-2.98
        c1.43-.64 2.08-2.31 1.44-3.74z
        m22.62.26h12.91c.67 0 4.71.77 4.71 3.8 0 2.51-3.1 3.41-5.65 3.41h-11.98z
        m0 17.56h9.89c.9 0 4.83.26 6.08 5.28.39 1.54 1.26 6.56 1.85 8.17.59 1.8 2.98 5.4 5.53 5.4h16.14a38.27 38.27 0 0 1 -3.54 4.1l-6.57-1.41c-1.53-.33-3.04.65-3.37 2.18l-1.56 7.28a38.27 38.27 0 0 1 -31.91-.15l-1.56-7.28c-.33-1.53-1.83-2.51-3.36-2.18l-6.43 1.38a38.27 38.27 0 0 1 -3.32-3.92h31.27c.35 0 .59-.06.59-.39v-11.06c0-.32-.24-.39-.59-.39h-9.15zm-14.43 25.33a3.11 3.11 0 0 1 3.02 3.11 3.11 3.11 0 0 1 -6.22 0 3.11 3.11 0 0 1 3.2-3.11zm46.05.14a3.11 3.11 0 0 1 3.02 3.11 3.11 3.11 0 0 1 -6.22 0 3.11 3.11 0 0 1 3.2-3.11z" />
    </g>
</svg>
</div>
<!--web-only-->
<p>To get started building development tools using the Rust programming language, we are going to be utilizing 2 crates. The first is a crate called <a href="https://github.com/FreeMasen/RESS"><code>ress</code></a> or Rusty ECMAScript Scanner, this crate is used to convert JavaScript text into a series of <code>Token</code>s. Next is <a href="https://github.com/FreeMasen/RESSA"><code>ressa</code></a> or Rusty ECMAScript Syntax Analyzer, this crate will take that series of <code>Token</code>s and build an Abstract Syntax Tree or AST. Either of these tools will be useful for building development tools however since the output of <code>ress</code> is essentially flat it means we can only build a much simpler kind of tool. Over the course of this book we will cover the basics of how to build a development tool with either of these crates.</p>
<!--web-only-end-->
<!--slides-only-->
<ul>
<li>What is RESS
<ul>
<li>Overview</li>
<li>Demo Project</li>
</ul>
</li>
<li>What is RESSA
<ul>
<li>Overview</li>
<li>Demo Project</li>
</ul>
</li>
<li>What is RESW (maybe)
<ul>
<li>Overview</li>
</ul>
</li>
</ul>
<!--slides-only-end-->
<script>var PresentationMode;!function(e){e[e.Slides=0]="Slides",e[e.Web=1]="Web"}(PresentationMode||(PresentationMode={}));var PresentationModeHider=function(){function e(){var t=this;(this.queryKey="presentation_mode",this.webClass="article-content",this.preClass="presentation-only",this.mode=this.getMode(),this.setMode(),this.assignClassesViaComments(),this.mode!==PresentationMode.Slides||""!==location.pathname&&"/"!==location.pathname)||document.querySelector(".sidebar > .chapter").firstChild.firstChild.click();window.addEventListener("keyup",function(e){e.altKey&&("p"!=e.key&&"P"!=e.key&&"KeyP"!=e.code||t.toggle())})}return e.prototype.assignClassesViaComments=function(){for(var e,t=document.createNodeIterator(document.body,NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_COMMENT,null),n=this.mode===PresentationMode.Web?"not-presenting":"presenting",o=null;e=t.nextNode();)if(8===e.nodeType){var s=e.nodeValue.trim();o="web-only"===s?this.webClass:"slides-only"===s?this.preClass:null}else 1===e.nodeType&&null!==o&&e.classList.add(o,n)},e.prototype.getMode=function(){var t=localStorage.getItem(this.queryKey);if(null===t)return PresentationMode.Web;try{var e=parseInt(t);return 1<e||e<0?(console.error("presentation_mode was out of range",e),PresentationMode.Web):e}catch(e){return console.error("presentation_mode present in localStorage but value is not an integer",t,e),PresentationMode.Web}},e.prototype.setMode=function(){localStorage.setItem(this.queryKey,this.mode.toString())},e.prototype.updatePage=function(){this.updateElements(document.querySelectorAll(".presentation-only")),this.updateElements(document.querySelectorAll(".article-content"))},e.prototype.updateElements=function(e){for(var t=0;t<e.length;t++){var n=e[t];this.mode===PresentationMode.Slides?n.classList.replace("not-presenting","presenting"):n.classList.replace("presenting","not-presenting")}},e.prototype.toggle=function(){switch(this.mode){case PresentationMode.Slides:this.mode=PresentationMode.Web;break;case PresentationMode.Web:this.mode=PresentationMode.Slides}this.setMode(),this.updatePage()},e}(),___presentationModeHider=new PresentationModeHider;</script><style>.presentation-only.not-presenting{display:none}.article-content.presenting{display:none}
</style>
<a class="header" href="#ress" id="ress"><h1><code>RESS</code></h1></a>
<!--slides-only-->
<ul>
<li><code>impl Iterator for Scanner</code></li>
<li>Converts text into <code>Token</code>s</li>
<li>Flat Structure</li>
</ul>
<!--slides-only-end-->
<!--web-only-->
<p>Before we start on any examples let's dig a little into what <code>ress</code> does. The job of a <strong>scanner</strong> or <strong>tokenizer</strong> in the parsing process is to convert raw text or bytes into logically separated parts called <em>tokens</em> and <code>ress</code> does just that. It reads your JavaScript text and then tells you what a given word or symbol might represent. It does this through the <code>Scanner</code> interface, to construct a scanner you pass it the text you would like it to tokenize.</p>
<!--web-only-end-->
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let js = &quot;var i = 0;&quot;;
    let scanner = Scanner::new(js);
#}</code></pre></pre>
<!--web-only-->
<p>Now that you have prepared a scanner, how do we use it? Well, the <code>Scanner</code> implements <code>Iterator</code> so we can actually use it in a for loop like so.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    for token in scanner {
        println!(&quot;{:#?}&quot;, token);
    }
#}</code></pre></pre>
<p>If we were to run the above program it would print to the terminal the following.</p>
<!--web-only-end-->
<pre><code>Item {
    token: Keyword(
        Var
    ),
    span: Span {
        start: 0,
        end: 3
    }
}
Item {
    token: Ident(
        Ident(
            &quot;i&quot;
        )
    ),
    span: Span {
        start: 4,
        end: 5
    }
}
Item {
    token: Punct(
        Assign
    ),
    span: Span {
        start: 6,
        end: 7
    }
}
Item {
    token: Numeric(
        Number(
            &quot;0&quot;
        )
    ),
    span: Span {
        start: 8,
        end: 9
    }
}
Item {
    token: Punct(
        SemiColon
    ),
    span: Span {
        start: 9,
        end: 10
    }
}
Item {
    token: EoF,
    span: Span {
        start: 10,
        end: 10
    }
}
</code></pre>
<!--web-only-->
<p>The scanner's <code>::next()</code> method returns an <code>Item</code> which has 2 properties <code>token</code> and <code>span</code>. The <code>span</code> is the byte index that starts and ends the token, the <code>token</code> property is going to be one variant of the <code>Token</code> enum which has the following variants.</p>
<ul>
<li><code>Token::Boolean(BooleanLiteral)</code> - The text <code>true</code> or <code>false</code></li>
<li><code>Token::Ident(Ident)</code> - A variable, function, or class name</li>
<li><code>Token::Null</code> - The text <code>null</code></li>
<li><code>Token::Keyword(Keyword)</code> - One of the 42 reserved words e.g. <code>function</code>, <code>var</code>, <code>delete</code>, etc</li>
<li><code>Token::Numeric(Number)</code> - A number literal, this can be an integer, a float, scientific notation, binary notation, octal notation, or hexadecimal notation e.g. <code>1.5e9</code>, <code>0xfff</code>, etc</li>
<li><code>Token::Punct(Punct)</code> - One of the 52 reserved symbols or combinations of symbols e.g. <code>*</code>, <code>&amp;&amp;</code>, <code>=&gt;</code>, etc</li>
<li><code>Token::String(StringLit)</code> - Either a double or single quoted string</li>
<li><code>Token::RegEx(RegEx)</code> - A Regular Expression literal e.g. <code>/.+/g</code></li>
<li><code>Token::Template(Template)</code> - A template string literal e.g. <code>one ${2} three</code></li>
<li><code>Token::Comment(Comment)</code> - A single line, multi-line or html comment</li>
</ul>
<p>For a more in depth look at these tokens, take a look at the <a href="../a.appendix/tokens.html">Appendix</a></p>
<p>Overall the output of our scanner isn't going to provide any context for these tokens, that means when we are building our development tools it is going to be a little harder to figure out what is going on with any given token. One way we could take that is to just build a tool that is only concerned with the token level of information. Say you work on a team of JavaScript developers that need to adhere to a strict code style because the organization needs their website to be usable in Internet Explorer 8. With that restriction there are a large number of APIs that are off the table, looking over <a href="https://caniuse.com/#compare=ie+8,firefox+64&amp;compare_cats=JS,JS%20API">this list</a> we can see how big that really is. It could be useful to have a linter that will check for the keywords and identifiers that are not available in IE8. let's try and build one.</p>
<!--web-only-end-->
<script>var PresentationMode;!function(e){e[e.Slides=0]="Slides",e[e.Web=1]="Web"}(PresentationMode||(PresentationMode={}));var PresentationModeHider=function(){function e(){var t=this;(this.queryKey="presentation_mode",this.webClass="article-content",this.preClass="presentation-only",this.mode=this.getMode(),this.setMode(),this.assignClassesViaComments(),this.mode!==PresentationMode.Slides||""!==location.pathname&&"/"!==location.pathname)||document.querySelector(".sidebar > .chapter").firstChild.firstChild.click();window.addEventListener("keyup",function(e){e.altKey&&("p"!=e.key&&"P"!=e.key&&"KeyP"!=e.code||t.toggle())})}return e.prototype.assignClassesViaComments=function(){for(var e,t=document.createNodeIterator(document.body,NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_COMMENT,null),n=this.mode===PresentationMode.Web?"not-presenting":"presenting",o=null;e=t.nextNode();)if(8===e.nodeType){var s=e.nodeValue.trim();o="web-only"===s?this.webClass:"slides-only"===s?this.preClass:null}else 1===e.nodeType&&null!==o&&e.classList.add(o,n)},e.prototype.getMode=function(){var t=localStorage.getItem(this.queryKey);if(null===t)return PresentationMode.Web;try{var e=parseInt(t);return 1<e||e<0?(console.error("presentation_mode was out of range",e),PresentationMode.Web):e}catch(e){return console.error("presentation_mode present in localStorage but value is not an integer",t,e),PresentationMode.Web}},e.prototype.setMode=function(){localStorage.setItem(this.queryKey,this.mode.toString())},e.prototype.updatePage=function(){this.updateElements(document.querySelectorAll(".presentation-only")),this.updateElements(document.querySelectorAll(".article-content"))},e.prototype.updateElements=function(e){for(var t=0;t<e.length;t++){var n=e[t];this.mode===PresentationMode.Slides?n.classList.replace("not-presenting","presenting"):n.classList.replace("presenting","not-presenting")}},e.prototype.toggle=function(){switch(this.mode){case PresentationMode.Slides:this.mode=PresentationMode.Web;break;case PresentationMode.Web:this.mode=PresentationMode.Slides}this.setMode(),this.updatePage()},e}(),___presentationModeHider=new PresentationModeHider;</script><style>.presentation-only.not-presenting{display:none}.article-content.presenting{display:none}
</style>
<a class="header" href="#building-an-ie8-linter" id="building-an-ie8-linter"><h1>Building an IE8 Linter</h1></a>
<!--web-only-->
<p>To get started we need to add <code>ress</code> to our dependencies. This project is also going to need <code>serde</code>, <code>serde_derive</code> and <code>toml</code> because it will rely on a <code>.toml</code> file to make the list of unavailable tokens configurable.</p>
<pre><code class="language-toml">[package]
name = &quot;lint-ie8&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Robert Masen &lt;r@robertmasen.pizza&gt;&quot;]
edition = &quot;2018&quot;

[dependencies]
ress = &quot;0.5&quot;
serde = &quot;1&quot;
serde_derive = &quot;1&quot;
toml = &quot;0.4&quot;
atty = &quot;0.2&quot;
</code></pre>
<p>Next we want to use the <code>Scanner</code> and <code>Token</code> from <code>ress</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_use]
extern crate serde_derive;
use ress::{
    Scanner,
    Token,
};
#}</code></pre></pre>
<p>Since we are using a <code>.toml</code> file to provide the list of banned tokens, let's create a struct that will represent our configuration.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Deserialize)]
struct BannedTokens {
    idents: Vec&lt;String&gt;,
    keywords: Vec&lt;String&gt;,
    puncts: Vec&lt;String&gt;,
    strings: Vec&lt;String&gt;,
}
#}</code></pre></pre>
<p>The toml file we are going to use is pretty big so but if you want to see what it looks like you can check it out <a href="../a.appendix/ie-8-banned.html">here</a>. Essentially it is a list of identifiers, strings, punctuation, and keywords that would cause an error when trying to run in IE8.</p>
<p>To start we need to deserialize that file, we can do that with the <code>std::fs::read_to_string</code> and <code>toml::from_str</code> functions.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let config_text = ::std::fs::read_to_string(&quot;banned_tokens.toml&quot;).expect(&quot;failed to read config&quot;);
    let banned: BannedTokens = from_str(&amp;config_text).expect(&quot;Failed to deserialize banned tokens&quot;);
#}</code></pre></pre>
<p>Now that we have a list of tokens that should not be included in our javascript, let's get that text. It would be useful to be able to take a path argument or read the raw js from stdin. The function will check for an argument first and fallback to reading from stdin, it looks something like this.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn get_js() -&gt; Result&lt;String, ::std::io::Error&gt; {
    let mut cmd_args = args();
    let _ = cmd_args.next(); //discard bin name
    let js = if let Some(file_name) = cmd_args.next() {
        let js = read_to_string(file_name)?;
        js
    } else {
        let mut std_in = ::std::io::stdin();
        let mut ret = String::new();
        if atty::is(atty::Stream::Stdin) {
            return Ok(ret)
        }
        std_in.read_to_string(&amp;mut ret)?;
        ret
    };
    Ok(js)
}
#}</code></pre></pre>
<p>we will call it like this.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let js = match get_js() {
        Ok(js) =&gt; if js.len() == 0 {
            print_usage();
            std::process::exit(1);
        } else {
            js
        },
        Err(_) =&gt; {
            print_usage();
            std::process::exit(1);
        }
    };
#}</code></pre></pre>
<p>We want to handle the failure when attempting to get the js, so we will match on the call to <code>get_js</code>. If everything went well we need to check if the text is an empty string, this means no argument was provided but the program was not pipped any text. In either of these failure cases we want to print a nice message about how the command should have been written and then exit with a non-zero status code. <code>print_usage</code> is a pretty simple function that will just print to stdout the two ways to use the program.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn print_usage() {
    println!(&quot;banned_tokens &lt;infile&gt;
cat &lt;path/to/file&gt; | banned_tokens&quot;);
}
#}</code></pre></pre>
<p>With that out of the way, we now can get into how we are going to solve the actual problem of finding these tokens in a javascript file. There are many ways to make this work but for this example we are going to wrap the <code>Scanner</code> in another struct that implements <code>Iterator</code>. First here is what that struct is going to look like.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct BannedFinder {
    scanner: Scanner,
    banned: BannedTokens,
}
#}</code></pre></pre>
<p>Before we get into the <code>impl Iterator</code> we should go over an <code>Error</code> implementation that we are going to use. It is relatively straight forward, the actual struct is going to be a tuple struct with three items. The first item is going to be a message that will include the token and type, the second and third are going to be the column/row of the banned token. We need to implement display (<code>Error</code> requires it) which will just create a nice error message for us.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)]
pub struct BannedError(String, usize, usize);

impl ::std::error::Error for BannedError {

}

impl ::std::fmt::Display for BannedError {
    fn fmt(&amp;self, f: &amp;mut ::std::fmt::Formatter) -&gt; ::std::fmt::Result {
        write!(f, &quot;Banned {} found at {}:{}&quot;, self.0, self.1, self.2)
    }
}
#}</code></pre></pre>
<p>The last thing we need to do is create a way to map from a byte index to a column/row pair. Thankfully the <code>Scanner</code> exposes the original text as a property <code>stream</code> so we can use that to figure out what line and column any index means. The first thing we need is the ability to tell when any given character is a new line character. JavaScript allows for 5 new line sequences (<code>\r</code>,<code>\n</code>, <code>\r\n</code>, <code>\u{2028}</code>, and <code>\u{2029}</code>) so a function that would test for that might look like this.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn is_js_new_line(c: char) -&gt; bool {
    c == '\n'
    || c == '\u{2028}'
    || c == '\u{2029}'
}
#}</code></pre></pre>
<p>Notice that we aren't testing for <code>\r</code>, this <em>could</em> come back to bite us but for this example the <code>\n</code> should be enough to catch <code>\r\n</code> and for simplicity's sake we can just say that your team does not support the <code>\r</code> new line. Now we can add a method to <code>BannedFinder</code> that will take an index and return the row/column pair.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl BannedFinder {
    fn get_position(&amp;self, idx: usize) -&gt; (usize, usize) {
        let (row, line_start) = self.scanner.stream[..idx]
            .char_indices()
            .fold((1, 0), |(row, line_start), (i, c)| if is_js_new_line(c) {
                (row + 1, i)
            } else {
                (row, line_start)
            });
        let col = if line_start == 0 {
            idx
        } else {
            idx.saturating_sub(line_start)
        };
        (row, col)
    }
}
#}</code></pre></pre>
<p>We need to capture two pieces of information, the first step what row we are on the second is the index that row started at. We can get both pieces of information by using the <code>char_indices</code> method on <code>&amp;str</code> which will give us an <code>Iterator</code> over tuples  the indices and <code>char</code>s in the string. We then <code>fold</code> that iterator into a single value, the row will start at 1 and the index will start at 0. If the current character is a new line we add one to the row and replace any previous index value, otherwise we move on. We are only counting the new lines from the start until the provided index, this will make sure we don't count any extra new lines. Now that we have the row number we need to calculate the column, if the <code>line_start</code> is 0 that means we didn't find new lines so we can just assume it is the first line, meaning the index is already the column, otherwise we need to subtract the <code>line_start</code> from the index.</p>
<p>Ok, now for the exciting part; we are going to <code>impl Iterator for BannedFinder</code> which will look like this.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Iterator for BannedFinder {
    type Item = Result&lt;(), BannedError&gt;;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if let Some(item) = self.scanner.next() {
            Some(match &amp;item.token {
                Token::Ident(ref id) =&gt; {
                    let id = id.to_string();
                    if self.banned.idents.contains(&amp;id) {
                        let (row, column) = self.get_position(item.span.start);
                        Err(BannedError(format!(&quot;identifier {}&quot;, id), row, column))
                    } else {
                        Ok(())
                    }
                },
                Token::Keyword(ref key) =&gt; {
                    if self.banned.keywords.contains(&amp;key.to_string()) {
                        let (row, column) = self.get_position(item.span.start);
                        Err(BannedError(format!(&quot;keyword {}&quot;, key.to_string()), row, column))
                    } else {
                        Ok(())
                    }
                },
                Token::Punct(ref punct) =&gt; {
                    if self.banned.puncts.contains(&amp;punct.to_string()) {
                        let (row, column) = self.get_position(item.span.start);
                        Err(BannedError(format!(&quot;punct {}&quot;, punct.to_string()), row, column))
                    } else {
                        Ok(())
                    }
                },
                Token::String(ref lit) =&gt; {
                    if self.banned.strings.contains(&amp;lit.no_quote()) {
                        let (row, column) = self.get_position(item.span.start);
                        Err(BannedError(format!(&quot;string {}&quot;, lit.to_string()), row, column))
                    } else {
                        Ok(())
                    }
                },
                _ =&gt; Ok(()),
            })
        } else {
            None
        }
    }
}
#}</code></pre></pre>
<p>First we need to define what the <code>Item</code> for our <code>Iterator</code> is. It is going to be a <code>Result&lt;(), BannedError&gt;</code>, this will allow the caller to check if an item passed inspection. Now we can add the <code>fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;</code> definition. Inside that we first want to make sure that the <code>Scanner</code> isn't returning <code>None</code>, if it is we can just return <code>None</code>. If the scanner returns and <code>Item</code> we want to check what kind of token it is, we can do that by matching on <code>&amp;item.token</code>.  We only care if the token is a <code>Keyword</code>, <code>Ident</code>, <code>Punct</code> or <code>String</code>, other wise we can say that the token passed. For each of these tokens we are going to check if the actual text is included in any of the <code>Vec&lt;String&gt;</code> properties of <code>self.banned</code>, if it is included we return a <code>BannedError</code> where the first property is a message containing the name of the token type and the text that token represents.</p>
<p>Now that we have all of the underlying infrastructure setup, let's use the <code>BannedFinder</code> in our <code>main</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    for item in finder {
        match item {
            Ok(_) =&gt; (),
            Err(msg) =&gt; println!(&quot;{}&quot;, msg),
        }
    }
#}</code></pre></pre>
<p>That is pretty much it. If you wanted to see the full project you can find it in the <a href="https://github.com/FreeMasen/rusty-ecma-book/tree/master/lint-ie8">lint-ie8</a> folder of this book's github repository.</p>
<!--web-only-end-->
<!--slides-only-->
<a class="header" href="#demo" id="demo"><h2>Demo</h2></a>
<!--slides-only-end-->
<script>var PresentationMode;!function(e){e[e.Slides=0]="Slides",e[e.Web=1]="Web"}(PresentationMode||(PresentationMode={}));var PresentationModeHider=function(){function e(){var t=this;(this.queryKey="presentation_mode",this.webClass="article-content",this.preClass="presentation-only",this.mode=this.getMode(),this.setMode(),this.assignClassesViaComments(),this.mode!==PresentationMode.Slides||""!==location.pathname&&"/"!==location.pathname)||document.querySelector(".sidebar > .chapter").firstChild.firstChild.click();window.addEventListener("keyup",function(e){e.altKey&&("p"!=e.key&&"P"!=e.key&&"KeyP"!=e.code||t.toggle())})}return e.prototype.assignClassesViaComments=function(){for(var e,t=document.createNodeIterator(document.body,NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_COMMENT,null),n=this.mode===PresentationMode.Web?"not-presenting":"presenting",o=null;e=t.nextNode();)if(8===e.nodeType){var s=e.nodeValue.trim();o="web-only"===s?this.webClass:"slides-only"===s?this.preClass:null}else 1===e.nodeType&&null!==o&&e.classList.add(o,n)},e.prototype.getMode=function(){var t=localStorage.getItem(this.queryKey);if(null===t)return PresentationMode.Web;try{var e=parseInt(t);return 1<e||e<0?(console.error("presentation_mode was out of range",e),PresentationMode.Web):e}catch(e){return console.error("presentation_mode present in localStorage but value is not an integer",t,e),PresentationMode.Web}},e.prototype.setMode=function(){localStorage.setItem(this.queryKey,this.mode.toString())},e.prototype.updatePage=function(){this.updateElements(document.querySelectorAll(".presentation-only")),this.updateElements(document.querySelectorAll(".article-content"))},e.prototype.updateElements=function(e){for(var t=0;t<e.length;t++){var n=e[t];this.mode===PresentationMode.Slides?n.classList.replace("not-presenting","presenting"):n.classList.replace("presenting","not-presenting")}},e.prototype.toggle=function(){switch(this.mode){case PresentationMode.Slides:this.mode=PresentationMode.Web;break;case PresentationMode.Web:this.mode=PresentationMode.Slides}this.setMode(),this.updatePage()},e}(),___presentationModeHider=new PresentationModeHider;</script><style>.presentation-only.not-presenting{display:none}.article-content.presenting{display:none}
</style>
<a class="header" href="#ressa" id="ressa"><h1>RESSA</h1></a>
<!--slides-only-->
<ul>
<li><code>impl Iterator for Parser</code></li>
<li>Converts stream of <code>Token</code>s into AST</li>
<li>Significantly more context</li>
</ul>
<!--slides-only-end-->
<!--web-only-->
<p>Before we get into how to use <code>ressa</code>, It is a good idea to briefly touch on the scope of a <strong>parser</strong> or <strong>syntax analyzer</strong>. The biggest thing to understand is that we still are not dealing with the <em>semantic</em> meaning of the program. That means <code>ressa</code> itself won't discover things like assigning to undeclared variables or attempting to call undefined functions because that would require more context. To that end, <code>ressa</code>'s true value isn't realized until it is embedded into another program that provide that context.</p>
<p>With that said <code>ressa</code> is providing a larger context as compared to what is provided by <code>ress</code>. It achieves that by wrapping the <code>Scanner</code> in a struct called <code>Parser</code>. Essentially <code>Parser</code> provides a way to keep track of what any given set of <code>Token</code>s might mean. <code>Parser</code> also implements <code>Iterator</code> over the enum <code>ProgramPart</code>, which has 3 cases representing the 3 different top level JavaScript constructs.</p>
<ul>
<li><code>Decl</code> - a variable/function/class declaration
<ul>
<li><code>Variable</code> - A top level variable declaration e.g. <code>let x = 0;</code></li>
<li><code>Class</code> - A named class definition at the top level</li>
<li><code>Function</code> - A named function definition at the top level</li>
<li><code>Import</code> - An ES Module import statement</li>
<li><code>Export</code> - An ES Module export statement</li>
</ul>
</li>
<li><code>Directive</code> - pretty much just 'use strict'</li>
<li><code>Statement</code> - A catch all for everything else
<ul>
<li><code>Block</code> - A collection of statements wrapped in curly braces</li>
<li><code>Break</code> - A break statement will exit a loop or labeled statement early</li>
<li><code>Continue</code> - A continue statement will short circuit a loop</li>
<li><code>Debugger</code> - the literal text <code>debugger</code></li>
<li><code>DoWhile</code> - A do loop executes the body before testing whether to continue</li>
<li><code>Empty</code> - A single semicolon</li>
<li><code>Expr</code> - A catch-all for everything else</li>
<li><code>For</code> - A c-style for loop e.g. <code>for (var i = 0; i &lt; 100; i++) ;</code></li>
<li><code>ForIn</code> - A for loop that assigns the key of an enumerable at the top of each iteration</li>
<li><code>ForOf</code> - A for loop that assigns the value of an iterable at the top of each iteration</li>
<li><code>If</code> - A set of if/else if/else statements</li>
<li><code>Labeled</code> - A statement that has been named by an attached identifier</li>
<li><code>Return</code> - The return statement that resolves a function's value</li>
<li><code>Switch</code> - A test <code>Expression</code> and a collection of <code>CaseStatements</code></li>
<li><code>Throw</code> - The throw keyword followed by an <code>Expression</code></li>
<li><code>Try</code> - A try/catch/finally block for catching <code>Throw</code>n items</li>
<li><code>Var</code> - A non-top level variable declaration</li>
<li><code>While</code> - A loop which continues based on a test <code>Expression</code></li>
<li><code>With</code> - An antiquated statement that changes the order of identifier resolution</li>
</ul>
</li>
</ul>
<p><code>Statement</code> being the real work-horse of the group, while a top level function definition would be a <code>Decl</code>, a non-top level function definition would be a <code>Statement</code>. Both <code>Decl</code> and <code>Statement</code> themselves are enums representing the different possible variations. Looking further into the <code>Statement</code> variants, you may notice there is another <em>catch all</em> in the <code>Expr</code> variant which contains an <code>Expression</code> enum which defines an even more granular set of program parts.</p>
<ul>
<li><code>Expression</code>
<ul>
<li><code>Assignment</code> - Assigning a value to a variable, this includes any update &amp; assign operations e.g. <code>x = 1</code>, <code>x +=1</code>, etc</li>
<li><code>Array</code> - An array literal e.g. <code>[1,2,3,4]</code></li>
<li><code>ArrowFunction</code> - An arrow function expression</li>
<li><code>Await</code> - Any expression preceded by the <code>await</code> keyword</li>
<li><code>Call</code> - Calling a function or method</li>
<li><code>Class</code> - A class expression is a class definition with an optional identifier that is assigned to a variable or used as an argument in a <code>Call</code> expression</li>
<li><code>Conditional</code> - Also known as the &quot;ternary&quot; operator e.g. <code>test ? consequent : alternate</code></li>
<li><code>Function</code> - A function expression is a function definition with an optional identifier that is either self executing, assigned to a variable or used as a <code>Call</code> argument</li>
<li><code>Ident</code> - The identifier of a variable, call argument, class, import, export or function</li>
<li><code>Literal</code> - A <em>primitive</em> literal</li>
<li><code>Logical</code> - Two expressions separated by <code>&amp;&amp;</code> or <code>||</code></li>
<li><code>Member</code> - Accessing a sub property on something. e.g. <code>[0,1,2][1]</code> or <code>console.log</code></li>
<li><code>MetaProperty</code> - Currently the only <code>MetaProperty</code> is in a function body you can check <code>new.target</code> to see if something was called with the <code>new</code> keyword</li>
<li><code>New</code> - A <code>Call</code> expression preceded by the <code>new</code> keyword</li>
<li><code>Object</code> - An object literal e.g. <code>{a: 1, b: 2}</code></li>
<li><code>Sequence</code> - Any sequence of expressions separated by commas</li>
<li><code>Spread</code> - the <code>...</code> operator followed by an expression</li>
<li><code>SuperExpression</code> - The <code>super</code> pseudo-keyword used for accessing properties of a <code>super</code> class</li>
<li><code>TaggedTemplate</code> - An identifier followed by a template literal <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_templates">see MDN for more info</a></li>
<li><code>ThisExpression</code> - The <code>this</code> pseudo-keyword used for accessing instance properties</li>
<li><code>Unary</code> - An operation (that is not an update) that requires on expression as an argument e.g. <code>delete x</code>, <code>!true</code>, etc</li>
<li><code>Update</code> - An operation that uses the <code>++</code> or <code>--</code> operator</li>
<li><code>Yield</code> - the <code>yield</code> contextual keyword followed by an optional expression for use in generator function</li>
</ul>
</li>
</ul>
<p>Most of the <code>Expression</code>, <code>Statement</code>, and <code>Decl</code> variants have associated values, to see more information about them check out the <a href="https://docs.rs/ressa">documentation</a>. There should be an example and description provided for each of the possible combinations.</p>
<p>With that long winded explanation of the <em>basic</em> structure we are working with let's take a look at how we would use the <code>Parser</code>.</p>
<!--web-only-end-->
<pre><pre class="playpen"><code class="language-rust">use ressa::*;

static JS: &amp;str = &quot;
function Thing(stuff) {
    this.stuff = stuff;
}
&quot;;

fn main() {
    let parser = Parser::new(JS).expect(&quot;Failed to create parser&quot;);
    for part in parser {
        let part = part.expect(&quot;Failed to parse part&quot;);
        println!(&quot;{:?}&quot;, part);
    }
}
</code></pre></pre>
<!--web-only-->
<p>If we were to run the above we would get the following output.</p>
<!--web-only-end-->
<pre><code class="language-ron">Script([
    Decl(
        Function(
            Function {
                id: Some(
                    &quot;Thing&quot;
                ),
                params: [
                    Pattern(
                        Identifier(
                            &quot;stuff&quot;
                        )
                    )
                ],
                body: [
                    Statement(
                        Expr(
                            Assignment(
                                AssignmentExpression {
                                    operator: Equal,
                                    left: Expr(
                                        Member(
                                            MemberExpression {
                                                object: ThisExpression,
                                                property: Ident(
                                                    &quot;stuff&quot;
                                                ),
                                                computed: false
                                            }
                                        )
                                    ),
                                    right: Ident(
                                        &quot;stuff&quot;
                                    )
                                }
                            )
                        )
                    )
                ],
                generator: false,
                is_async: false
            }
        )
    )
])
</code></pre>
<!--web-only-->
<p>If we walk through the output, we start by seeing that the</p>
<ol>
<li>This program consists of a single part which is a  <code>ProgramPart::Decl</code></li>
<li>Inside of that is a <code>Declaration::Function</code></li>
<li>Inside of that is a <code>Function</code>
<ol>
<li>It has an <code>id</code>, which is an optional <code>Identifier</code>, with the value of <code>Some(&quot;Thing&quot;)</code></li>
<li>It has a one item vec of <code>Pattern</code>s in <code>params</code>
<ol>
<li>Which is a <code>Pattern::Identifier</code></li>
<li>Inside of that is an <code>Identifier</code> with the value of &quot;stuff&quot;</li>
</ol>
</li>
<li>It has a body that is a one item vec of <code>ProgramPart</code>s
<ol>
<li>The item is a <code>ProgramPart::Statement</code></li>
<li>Which is a <code>Statement::Expr</code></li>
<li>Inside of that is an <code>Expression::Assignment</code></li>
<li>Inside of that is an <code>AssignmentExpression</code>
<ol>
<li>Which has an <code>operator</code> of <code>Equal</code></li>
<li>The <code>left</code> hand side is an <code>Expression::Member</code>
<ol>
<li>The <code>object</code> being <code>Expression::This</code></li>
<li>The <code>property</code> being <code>Expression::Ident</code> with the value of &quot;stuff&quot;</li>
</ol>
</li>
<li>The <code>right</code> hand side is an <code>Expression::Ident</code> with the value of &quot;stuff&quot;</li>
<li><code>computed</code> is false</li>
</ol>
</li>
</ol>
</li>
<li>It is not a <code>generator</code></li>
<li><code>is_async</code> is false</li>
</ol>
</li>
</ol>
<p>Phew! That is quite a lot of information! A big part of why we need to be that verbose is because of the &quot;you can do anything&quot; nature of JavaScript. Let's use the <code>MemberExpression</code> as an example, below are a collection of ways to write a <code>MemberExpression</code> in JavaScript.</p>
<pre><code class="language-js">console.log;
console['log'];
const logVar = 'log';
console[logVar];
console[['l','o','g'].join('')];
class Log {
    toString() {
        return 'log';
    }
}
const logToString = new Log();
console[logToString];
function logFunc() {
    return 'log';
}
console[logFunc()];
function getConsole() {
    return console
}
getConsole()[logFunc()];
getConsole().log;
</code></pre>
<p>And with the way JavaScript has evolved this probably isn't an exhaustive list of ways to construct a <code>MemberExpression</code>. With the level of information <code>ressa</code> provides we have enough to truly understand the <em>syntactic</em> meaning of the text. This will enable us to build more powerful tools to analyze and/or manipulate any given JavaScript program. With the pervasiveness of <a href="https://en.wikipedia.org/wiki/Debugging#Techniques">print debugging</a>, wouldn't it be nice if we had a tool that would automatically insert a <code>console.log</code> at the top of every function and method in a program? We could make it print the name of that function and also each of the arguments, let's try and build one.</p>
<!--web-only-end-->
<script>var PresentationMode;!function(e){e[e.Slides=0]="Slides",e[e.Web=1]="Web"}(PresentationMode||(PresentationMode={}));var PresentationModeHider=function(){function e(){var t=this;(this.queryKey="presentation_mode",this.webClass="article-content",this.preClass="presentation-only",this.mode=this.getMode(),this.setMode(),this.assignClassesViaComments(),this.mode!==PresentationMode.Slides||""!==location.pathname&&"/"!==location.pathname)||document.querySelector(".sidebar > .chapter").firstChild.firstChild.click();window.addEventListener("keyup",function(e){e.altKey&&("p"!=e.key&&"P"!=e.key&&"KeyP"!=e.code||t.toggle())})}return e.prototype.assignClassesViaComments=function(){for(var e,t=document.createNodeIterator(document.body,NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_COMMENT,null),n=this.mode===PresentationMode.Web?"not-presenting":"presenting",o=null;e=t.nextNode();)if(8===e.nodeType){var s=e.nodeValue.trim();o="web-only"===s?this.webClass:"slides-only"===s?this.preClass:null}else 1===e.nodeType&&null!==o&&e.classList.add(o,n)},e.prototype.getMode=function(){var t=localStorage.getItem(this.queryKey);if(null===t)return PresentationMode.Web;try{var e=parseInt(t);return 1<e||e<0?(console.error("presentation_mode was out of range",e),PresentationMode.Web):e}catch(e){return console.error("presentation_mode present in localStorage but value is not an integer",t,e),PresentationMode.Web}},e.prototype.setMode=function(){localStorage.setItem(this.queryKey,this.mode.toString())},e.prototype.updatePage=function(){this.updateElements(document.querySelectorAll(".presentation-only")),this.updateElements(document.querySelectorAll(".article-content"))},e.prototype.updateElements=function(e){for(var t=0;t<e.length;t++){var n=e[t];this.mode===PresentationMode.Slides?n.classList.replace("not-presenting","presenting"):n.classList.replace("presenting","not-presenting")}},e.prototype.toggle=function(){switch(this.mode){case PresentationMode.Slides:this.mode=PresentationMode.Web;break;case PresentationMode.Web:this.mode=PresentationMode.Slides}this.setMode(),this.updatePage()},e}(),___presentationModeHider=new PresentationModeHider;</script><style>.presentation-only.not-presenting{display:none}.article-content.presenting{display:none}
</style>
<a class="header" href="#building-a-debug-helper" id="building-a-debug-helper"><h1>Building a Debug Helper</h1></a>
<!--slides-only-->
<a class="header" href="#demo-1" id="demo-1"><h2>Demo</h2></a>
<!--slides-only-end-->
<!--web-only-->
<p>To simplify things, we are just going to lift the technique for getting the JavaScript text from the <a href="../02.ress/2.html">ress example</a>, so we won't be covering that again.</p>
<p>With that out of the way let's take a look at the <code>Cargo.toml</code> and <code>use</code> statements for our program.</p>
<pre><code class="language-toml">[package]
name = &quot;console_logify&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Robert Masen &lt;r@robertmasen.pizza&gt;&quot;]
edition = &quot;2018&quot;

[dependencies]
ressa = &quot;0.2&quot;
atty = &quot;0.2&quot;
resw = &quot;0.1&quot;
</code></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use ressa::{
    Parser,
    node::*,
};
use std::{
    io::Read,
    env::args,
    fs::read_to_string,
};
#}</code></pre></pre>
<p>This will make sure that all of the items we will need from <code>ressa</code> are in scope. Now we can start defining our method for inserting the debug logging into any functions that we find. To start we are going to create a function that will generate a new <code>ProgramPart::Statement</code> that will represent our call to <code>console.log</code> which might look like this.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn console_log(args: Vec&lt;Expression&gt;) -&gt; ProgramPart {
    ProgramPart::Statement(
        Statement::Expr(
            Expression::call(
                Expression::member(
                    Expression::ident(&quot;console&quot;),
                    Expression::ident(&quot;log&quot;),
                    false,
                ),
                args,
            )
        )
    )
#}</code></pre></pre>
<p>We need to make the arguments configurable so we can insert the context information for each instance of a function but otherwise it is a pretty straight forward. Now that we have that, we need to start digging into the <code>ProgramPart</code> to identify anything we want to modify. Since <code>Parser</code> implements <code>Iterator</code> and its <code>Item</code> is <code>Result&lt;ProgramPart, Error&gt;</code> we first need to use <code>filter_map</code> to extract the <code>ProgramPart</code> from the result. It would probably be good to handle the error case here but for the sake of simplicity we are going to skip any errors. Now that we have an <code>Iterator</code> over <code>ProgramPart</code>s we can use <code>map</code> to update each part.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let js = get_js().expect(&quot;Unable to get JavaScript&quot;);
    let parser = Parser::new(&amp;js).expect(&quot;Unable to construct parser&quot;);
    for part in parser.filter_map(|p| p.ok()).map(map_part) {
        //FIXME: Write updated program part to somewhere
    }
}
</code></pre></pre>
<p>With that in mind the entry point is going to be a function that takes a <code>ProgramPart</code> and returns a new <code>ProgramPart</code>. It might look like this</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn map_part(part: ProgramPart) -&gt; ProgramPart {
    match part {
        ProgramPart::Decl(ref decl) =&gt; ProgramPart::Decl(map_decl(decl)),
        ProgramPart::Statement(ref stmt) =&gt; ProgramPart::Statement(map_stmt(stmt)),
        ProgramPart::Directive(_) =&gt; part,
    }
}
#}</code></pre></pre>
<p>We are going to match on the part provided and either return that part if it is a <code>Directive</code> or if it isn't we need to investigate further to discover if it is a function or not. We do that in two places <code>map_decl</code> and <code>map_stmt</code> both of which are going to utilize similar method for digging further into the tree.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn map_decl(decl: &amp;Declaration) -&gt; Declaration {
    match decl {
        Declaration::Function(ref f) =&gt; Declaration::Function(map_func(f)),
        Declaration::Class(ref class) =&gt; Declaration::Class(map_class(class)),
        _ =&gt; decl.clone()
    }
}

fn map_stmt(stmt: &amp;Statement) -&gt; Statement {
    match stmt {
        Statement::Expr(ref expr) =&gt; Statement::Expr(map_expr(expr)),
        _ =&gt; stmt.clone(),
    }
}
#}</code></pre></pre>
<p>There are two ways for a <code>Declaration</code> to resolve into a function or method and that is with the <code>Function</code> and <code>Class</code> variants while a <code>Statement</code> can end up there if it is an <code>Expr</code>. When we include <code>map_expr</code> we see that there are cases for both <code>Function</code> and <code>Class</code> in the <code>Expression</code> enum. That means once we get past those we will be handling the rest in the exact same way.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn map_expr(expr: &amp;Expression) -&gt; Expression {
    match expr {
        Expression::Function(ref f) =&gt; Expression::Function(map_func(f)),
        Expression::Class(ref c) =&gt; Expression::Class(map_class(c)),
        _ =&gt; expr.clone(),
    }
}
#}</code></pre></pre>
<p>Finally we are going to start manipulating the AST in <code>map_func</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn map_func(func: &amp;Function) -&gt; Function {
    let mut f = func.clone();
    let mut args = vec![];
    if let Some(ref name) = f.id {
        args.push(
            Expression::string(&amp;format!(&quot;'{}'&quot;, name))
        );
    }
    for arg in f.params.iter().filter_map(|a| match a {
        FunctionArg::Expr(e) =&gt; match e {
            Expression::Ident(i)  =&gt; Some(i),
            _ =&gt; None,
        },
        FunctionArg::Pattern(p) =&gt; match p {
            Pattern::Identifier(i) =&gt; Some(i),
            _ =&gt; None,
        },
    }) {
        args.push(Expression::ident(arg));
    }
    f.body.insert(
        0,
        console_log(args),
    );
    f.body = f.body.into_iter().map(map_part).collect();
    f
}

#}</code></pre></pre>
<p>The first thing we are going to do is to clone the <code>func</code> to give us a mutable version. Next we are going to check if the <code>id</code> is <code>Some</code>, if it is we can add that name to our <code>console.log</code> arguments. Now function arguments can be pretty complicated, to try and keep things simple we are going to only worry about the ones that are either <code>Expression::Ident</code> or <code>Pattern::Identifier</code>. To build something more robust it might be good to include destructured arguments or arguments with default values but for this example we are just going to keep it simple.</p>
<p>First we are going to <code>filter_map</code> the <code>func.params</code> to only get the items that ultimately resolve to <code>Identifer</code>s, at that point we can wrap all of these identifiers in an <code>Expression::Ident</code> and add them to the <code>console.log</code> args. Now we can simply insert the result of passing those args to <code>console_log</code> at the first position of the <code>func.body</code>. Because functions can appear in the body of other functions we also want to map all of the <code>func.body</code> program parts. Once that has completed we can return the updated <code>func</code> to the caller.</p>
<p>The next thing we are going to want to deal with is <code>Class</code>, we want to insert console.log into the top of each method on a class. This is a bit unique because we also want to provide the name of that class (if it exists) as the first argument to console.log. That might look like this.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]

#fn main() {
fn map_class(class: &amp;Class) -&gt; Class {
    let mut class = class.clone();
    let prefix =  if let Some(ref id) = class.id {
        id.clone()
    } else {
        String::new()
    };

    class.body = class.body
                        .iter()
                        .map(|prop| map_class_prop(&amp;prefix, prop))
                        .collect();
    class
}

fn map_class_prop(prefix: &amp;str, prop: &amp;Property) -&gt; Property {
    let mut prop = prop.clone();
    let mut args = match prop.kind {
        PropertyKind::Ctor =&gt; {
            vec![Expression::string(&amp;format!(&quot;'new {}'&quot;, prefix))]
        },
        PropertyKind::Get =&gt; {
            vec![
                Expression::string(&amp;format!(&quot;'{}'&quot;, prefix)),
                Expression::string(&quot;get&quot;),
            ]
        },
        PropertyKind::Set =&gt; {
            vec![
                Expression::string(&amp;format!(&quot;'{}'&quot;, prefix)),
                Expression::string(&quot;set&quot;),
            ]
        },
        PropertyKind::Method =&gt; {
            vec![
                Expression::string(&amp;format!(&quot;'{}'&quot;, prefix)),
            ]
        },
        _ =&gt; vec![],
    };
    match &amp;prop.key {
        PropertyKey::Ident(ref i) =&gt; {
            if i != &quot;constructor&quot; {
                args.push(Expression::string(&amp;format!(&quot;'{}'&quot;, i)));
            }
        },
        PropertyKey::Literal(ref l) =&gt; {
            match l {
                Literal::Boolean(ref b) =&gt; {
                    args.push(Expression::string(&amp;format!(&quot;'{}'&quot;, b)));
                },
                Literal::Null =&gt; {
                    args.push(Expression::string(&quot;'null'&quot;));
                },
                Literal::Number(ref n) =&gt; {
                    args.push(Expression::string(&amp;format!(&quot;'{}'&quot;, n)));
                }
                Literal::RegEx(ref r) =&gt; {
                    args.push(Expression::string(&amp;format!(&quot;'/{}/{}'&quot;, r.pattern, r.flags)));
                },
                Literal::String(ref s) =&gt; {
                    if s != &quot;constructor&quot; {
                        args.push(Expression::string(s));
                    }
                },
                _ =&gt; (),
            }
        },
        PropertyKey::Pattern(ref p) =&gt; {
            match p {
                Pattern::Identifier(ref i) =&gt; {
                    args.push(Expression::string(&amp;format!(&quot;'{}'&quot;, i)));
                },
                _ =&gt; (),
            }
        },
    }
    if let PropertyValue::Expr(ref mut expr) = prop.value {
        match expr {
            Expression::Function(ref mut f) =&gt; {
                for ref arg in &amp;f.params {
                    match arg {
                        FunctionArg::Expr(ref expr) =&gt; {
                            match expr {
                                Expression::Ident(_) =&gt; args.push(expr.clone()),
                                _ =&gt; (),
                            }
                        },
                        FunctionArg::Pattern(ref pat) =&gt; {
                            match pat {
                                Pattern::Identifier(ref ident) =&gt; {
                                    args.push(Expression::ident(ident))
                                },
                                _ =&gt; {},
                            }
                        }
                    }
                }
                f.body.insert(0,
                    console_log(args)
                )
            },
            _ =&gt; (),
        }
    }
    prop
#}</code></pre></pre>
<p>Here we have two functions, the first pulls out the id from the provided class or uses an empty string of it doesn't exist. We then just pass that off to <code>map_class_prop</code> which will handle all of the different types of properties a class can have. The first thing this does is map the <code>prefix</code> into the right format, so a call to <code>new Thing()</code> would print <code>new Thing</code>, or a get method would print <code>Thing get</code> before the method name. Next we take a look at the <code>property.key</code>, this will provide us with the name of our function, but according to the specification a class property key can be an identifier, a literal value, or a pattern, so we need to figure out what the name of this method is by digging into that value. First in the case that it is an ident we want to add it to the args, unless it is the value <code>constructor</code> because we already put the <code>new</code> keyword in that one. Next we can pull out the literal values and add those as they appear. Lastly we will only handle the pattern case when it is a <code>Pattern::Identifier</code> otherwise we will just skip it. Now to get the parameter names from the method definition we need to look at the <code>property.value</code> which should always be an <code>Expression::Function</code>. Once we match on that we simply repeat the process of <code>map_function</code> pulling the args out but only when they are <code>Ident</code>s and then passing that along to <code>console_log</code> and inserting that <code>Expression</code> at the top of the function body.</p>
<p>At this point we have successfully updated our AST to include a call to <code>console.log</code> at the top of each function and method in our code. Now the big question is how do we write that out to a file. This problem is not a small one, in the next section we are going to cover a third crate <code>resw</code> that we can use to finish this project.</p>
<!--web-only-end-->
<script>var PresentationMode;!function(e){e[e.Slides=0]="Slides",e[e.Web=1]="Web"}(PresentationMode||(PresentationMode={}));var PresentationModeHider=function(){function e(){var t=this;(this.queryKey="presentation_mode",this.webClass="article-content",this.preClass="presentation-only",this.mode=this.getMode(),this.setMode(),this.assignClassesViaComments(),this.mode!==PresentationMode.Slides||""!==location.pathname&&"/"!==location.pathname)||document.querySelector(".sidebar > .chapter").firstChild.firstChild.click();window.addEventListener("keyup",function(e){e.altKey&&("p"!=e.key&&"P"!=e.key&&"KeyP"!=e.code||t.toggle())})}return e.prototype.assignClassesViaComments=function(){for(var e,t=document.createNodeIterator(document.body,NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_COMMENT,null),n=this.mode===PresentationMode.Web?"not-presenting":"presenting",o=null;e=t.nextNode();)if(8===e.nodeType){var s=e.nodeValue.trim();o="web-only"===s?this.webClass:"slides-only"===s?this.preClass:null}else 1===e.nodeType&&null!==o&&e.classList.add(o,n)},e.prototype.getMode=function(){var t=localStorage.getItem(this.queryKey);if(null===t)return PresentationMode.Web;try{var e=parseInt(t);return 1<e||e<0?(console.error("presentation_mode was out of range",e),PresentationMode.Web):e}catch(e){return console.error("presentation_mode present in localStorage but value is not an integer",t,e),PresentationMode.Web}},e.prototype.setMode=function(){localStorage.setItem(this.queryKey,this.mode.toString())},e.prototype.updatePage=function(){this.updateElements(document.querySelectorAll(".presentation-only")),this.updateElements(document.querySelectorAll(".article-content"))},e.prototype.updateElements=function(e){for(var t=0;t<e.length;t++){var n=e[t];this.mode===PresentationMode.Slides?n.classList.replace("not-presenting","presenting"):n.classList.replace("presenting","not-presenting")}},e.prototype.toggle=function(){switch(this.mode){case PresentationMode.Slides:this.mode=PresentationMode.Web;break;case PresentationMode.Web:this.mode=PresentationMode.Slides}this.setMode(),this.updatePage()},e}(),___presentationModeHider=new PresentationModeHider;</script><style>.presentation-only.not-presenting{display:none}.article-content.presenting{display:none}
</style>
<a class="header" href="#resw" id="resw"><h1>RESW</h1></a>
<!--web-only-->
<p>While <code>ress</code> and <code>ressa</code> consume text and generate data structures, <code>resw</code> is going to consume data structures and write out text. This means it can do the heavy lifting when solving the problem our debug logging project left us with. However instead of just sweeping that under the rug, we are going to go over how <code>resw</code> works. Because the nature of JavaScript, <code>resw</code> makes some style decisions that might not work for everyone, by going over the project in detail the hope is that other's will feel enabled to either contribute a configuration option into <code>resw</code> or even implement their own project that consumes <code>ressa</code>'s AST and generates text.</p>
<p>If you are just interested in seeing how we are going to finish the project from the last chapter, feel free to move ahead.</p>
<p>Similar to the structure of <code>ressa</code>, <code>resw</code> exposes a struct that will keep track of the context for us called <code>Writer</code>. There are 2 methods for constructing a <code>Writer</code>, the first is the <code>::new</code> method the second is the <code>::builder</code> method that utilizes the <em>builder</em> pattern to customize some options. Those options include</p>
<ul>
<li>New line character (default <code>\n</code>)</li>
<li>Quote (default to use origin quotation mark)
<ul>
<li>Setting this to any value will force all of the string literals in the provided JavaScript to be re-written with the provided quotes</li>
</ul>
</li>
<li>Indent (default 4 spaces)</li>
</ul>
<p>Either method you are going to need to provide the destination, this can be anything that implements the <code>std::io::Write</code> trait. For testing purposes the crate provides an implementor of <code>Write</code> in <code>WriteString</code>, we are not going to cover that here but a more detailed explanation can be found in the <a href="./a.appendix/string.writer.html">appendix</a>.</p>
<p>Once a <code>Writer</code> is constructed, it provides an API surface that should cover most of the <code>ressa</code> AST. The primary entry-point for is going to be either <code>write_program</code> or <code>write_part</code>. For the most part, the primary role of the writer is going to be incrementally move down the AST until we find something that we are confident in exactly what to write. Let's take the following js as an example.</p>
<pre><code class="language-js">function Thing(stuff) {
    this.stuff = stuff;
}
let thing = new Thing('argument');
</code></pre>
<p>If we run that that through the <code>ressa::Parser</code>, we would see the following AST.</p>
<pre><code class="language-ron">Decl(
    Function(
        Function {
            id: Some(
                &quot;Thing&quot;
            ),
            params: [
                Pattern(
                    Identifier(
                        &quot;stuff&quot;
                    )
                )
            ],
            body: [
                Statement(
                    Expr(
                        Assignment(
                            AssignmentExpression {
                                operator: Equal,
                                left: Expr(
                                    Member(
                                        MemberExpression {
                                            object: ThisExpression,
                                            property: Ident(
                                                &quot;stuff&quot;
                                            ),
                                            computed: false
                                        }
                                    )
                                ),
                                right: Ident(
                                    &quot;stuff&quot;
                                )
                            }
                        )
                    )
                )
            ],
            generator: false,
            is_async: false
        }
    )
)
Decl(
    Variable(
        Let,
        [
            VariableDecl {
                id: Identifier(
                    &quot;thing&quot;
                ),
                init: Some(
                    New(
                        NewExpression {
                            callee: Ident(
                                &quot;Thing&quot;
                            ),
                            arguments: [
                                Literal(
                                    String(
                                        &quot;\'argument\'&quot;
                                    )
                                )
                            ]
                        }
                    )
                )
            }
        ]
    )
)
</code></pre>
<p>Using that, let's take a look at how <code>resw</code> would generate the text to represent our AST. First we would enter at <code>write_part</code> with the first <code>ProgramPart</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn write_part(&amp;mut self, part: &amp;ProgramPart) -&gt; Res {
    self.at_top_level = true;
    self._write_part(part)?;
    self.write_new_line()?;
    Ok(())
}
#}</code></pre></pre>
<p>Interestingly enough, <code>write_part</code> is really more concerned with maintaining a context flag for if we are at the top level or not, this becomes important when trying to determine if any expression needs to be wrapped in parentheses. Almost all of the work is going to be passed off to an internal private function <code>_write_part</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn _write_part(&amp;mut self, part: &amp;ProgramPart) -&gt; Res {
    self.write_leading_whitespace()?;
    match part {
        ProgramPart::Decl(decl) =&gt; self.write_decl(decl)?,
        ProgramPart::Directive(dir) =&gt; self.write_directive(dir)?,
        ProgramPart::Statement(stmt) =&gt; self.write_stmt(stmt)?,
    }
    Ok(())
}
#}</code></pre></pre>
<p>The first thing we want to do is make sure that any leading whitespace is included with <code>write_leading_whitespace</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn write_leading_whitespace(&amp;mut self) -&gt; Res {
    self.write(&amp;self.indent.repeat(self.current_indent))?;
    Ok(())
}
#}</code></pre></pre>
<p>This is achieved by looking at the <code>current_indent</code> and writing the configurable property <code>indent</code> to the destination repeated the for our current indent level, so if our indent was <code>\t</code> and we were at level 2 it would write <code>&quot;\t\t&quot;</code>. Internally the <code>write</code> method just writes a single <code>&amp;str</code> to the destination. After we write our leading whitespace, we can start to descend the AST, we do that by matching on the part. You can see that there is a branch for each of the possible enum variants, looking back at the example, we know the next step would be to head to <code>write_decl</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn write_decl(&amp;mut self, decl: &amp;Declaration) -&gt; Res {
    match decl {
        Declaration::Variable(ref kind, ref decls) =&gt; self.write_variable_decls(kind, decls)?,
        Declaration::Class(ref class) =&gt; {
            self.at_top_level = false;
            self.write_class(class)?;
            self.write_new_line()?;
        },
        Declaration::Function(ref func) =&gt; {
            self.at_top_level = false;
            self.write_function(func)?;
            self.write_new_line()?;
        },
        Declaration::Export(ref exp) =&gt; self.write_export_decl(exp)?,
        Declaration::Import(ref imp) =&gt; self.write_import_decl(imp)?,
    };
    Ok(())
}
#}</code></pre></pre>
<p>Moving further down we simply match on the the declaration handling each variant as needed. For our example we would move into the <code>Declaration::Function</code> branch. The first step in that branch is to set the context flag <code>at_top_level</code> to <code>false</code> and then move into the <code>write_function</code> method.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn write_function(&amp;mut self, func: &amp;Function) -&gt; Res {
    if func.is_async {
        self.write(&quot;async &quot;)?;
    }
    self.write(&quot;function&quot;)?;
    if let Some(ref id) = func.id {
        self.write(&quot; &quot;)?;
        if func.generator {
            self.write(&quot;*&quot;)?;
        }
        self.write(id)?;
    } else if func.generator {
        self.write(&quot;*&quot;)?;
    }
    self.write_function_args(&amp;func.params)?;
    self.write(&quot; &quot;)?;
    self.write_function_body(&amp;func.body)
}
#}</code></pre></pre>
<p>Here we are going to actually start writing some information out to our destination. First is we check the flag on <code>Function</code> to see if we need to write the <code>async</code> keyword, next we write the keyword <code>function</code> followed by a check to see if the id is <code>Some</code>. If so we need to check the flag on <code>Function</code> to see if that function is a generator, if it is we need to add a <code>*</code> before the id, and Lastly we write the <code>id</code></p>
<p>Now that we have gotten though that we can start to look at the parameters and body. First we are going to pass off the parameters to <code>write_function_args</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Write the arguments of a function or method definition
/// ```js
/// function(arg1, arg2) {
/// }
/// ```
pub fn write_function_args(&amp;mut self, args: &amp;[FunctionArg]) -&gt; Res {
    self.write(&quot;(&quot;)?;
    let mut after_first = false;
    for ref arg in args {
        if after_first {
            self.write(&quot;, &quot;)?;
        } else {
            after_first = true;
        }
        self.write_function_arg(arg)?;
    }
    self.write(&quot;)&quot;)?;
    Ok(())
}
#}</code></pre></pre>
<p>The first step here is to write the open parenthesis, next we are going to use a flag <code>after_first</code> to help with handing if a comma should be written before the argument. This is the first place that we have seen where <code>resw</code> is making a style choice, all function parameters will not include a trailing comma. Ideally style choices will be configurable in the future but currently this one is not. Now that we have handled the comma situation we can pass the argument off to <code>write_function_arg</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn write_function_arg(&amp;mut self, arg: &amp;FunctionArg) -&gt; Res {
    match arg {
        FunctionArg::Expr(ref ex) =&gt; self.write_expr(ex)?,
        FunctionArg::Pattern(ref pa) =&gt; self.write_pattern(pa)?,
    }
    Ok(())
}
#}</code></pre></pre>
<p>Here we see another function that simply move us further down the AST. Function arguments can be either expressions or patterns so we need to handle both. For our example we are going to head down the <code>Pattern</code> branch with <code>write_pattern</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn write_pattern(&amp;mut self, pattern: &amp;Pattern) -&gt; Res {
    match pattern {
        Pattern::Identifier(ref i) =&gt; self.write(i),
        Pattern::Object(ref o) =&gt; self.write_object_pattern(o),
        Pattern::Array(ref a) =&gt; self.write_array_pattern(a.as_slice()),
        Pattern::RestElement(ref r) =&gt; self.write_rest_element(r),
        Pattern::Assignment(ref a) =&gt; self.write_assignment_pattern(a),
    }
}
#}</code></pre></pre>
<p>Most of the options here are simply going to continue branching down our AST, however for our example we are going to head down the first match arm with <code>Pattern::Identifer</code> and just write that string out to our destination.</p>
<p>Moving back up we only had one parameter for our function signature so we finish out <code>write_function_args</code> with a closing parenthesis. That then leads us to <code>write_function_body</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn write_function_body(&amp;mut self, body: &amp;FunctionBody) -&gt; Res {
    if body.len() == 0 {
        self.write(&quot;{ &quot;)?;
    } else {
        self.write_open_brace()?;
        self.write_new_line()?;
    }
    for ref part in body {
        self._write_part(part)?;
    }
    if body.len() == 0 {
        self.write(&quot;}&quot;)?;
    } else {
        self.write_close_brace()?;
    }
    Ok(())
}
#}</code></pre></pre>
<p>The first thing we need to do is take a look at the <code>&amp;FunctionBody</code> which is a type alias for <code>Vec&lt;ProgramPart&gt;</code>. We check to see if this function has any body, if not we just write a single open curly brace, if it does we want to write the curly brace using <code>write_open_brace</code>, this is a convenience method for writing the character and also incrementing the <code>current_indent</code>, lastly we write a new line. Now we loop over each of the <code>ProgramPart</code>s in <code>body</code> and pass that off to <code>_write_body</code>. For our example there is only going to be one part. This part is a <code>ProgramPart::Statement</code> which would be handled by <code>write_stmt</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn write_stmt(&amp;mut self, stmt: &amp;Statement) -&gt; Res {
    let mut semi = true;
    let mut new_line = true;
    let cached_state = self.at_top_level;
    match stmt {
        Statement::Empty =&gt; {
            new_line = false;
        },
        Statement::Debugger =&gt; self.write_debugger_stmt()?,
        Statement::Expr(ref stmt) =&gt; {
            let wrap = match stmt {
                Expression::Literal(_)
                | Expression::Object(_)
                | Expression::Function(_) 
                | Expression::Binary(_) =&gt; true,
                _ =&gt; false,
            };
            if wrap {
                self.write_wrapped_expr(stmt)?
            } else {
                self.write_expr(stmt)?
            }
        },
        Statement::Block(ref stmt) =&gt; {
            self.at_top_level = false;
            self.write_block_stmt(stmt)?;
            semi = false;
            new_line = false;
            self.at_top_level = cached_state;
        }
        Statement::With(ref stmt) =&gt; {
            self.write_with_stmt(stmt)?;
            semi = false;
        }
        Statement::Return(ref stmt) =&gt; self.write_return_stmt(stmt)?,
        Statement::Labeled(ref stmt) =&gt; {
            self.write_labeled_stmt(stmt)?;
            semi = false;
        }
        Statement::Break(ref stmt) =&gt; self.write_break_stmt(stmt)?,
        Statement::Continue(ref stmt) =&gt; self.write_continue_stmt(stmt)?,
        Statement::If(ref stmt) =&gt; {
            self.write_if_stmt(stmt)?;
            semi = false;
        }
        Statement::Switch(ref stmt) =&gt; {
            self.at_top_level = false;
            self.write_switch_stmt(stmt)?;
            semi = false;
        }
        Statement::Throw(ref stmt) =&gt; self.write_throw_stmt(stmt)?,
        Statement::Try(ref stmt) =&gt; {
            self.write_try_stmt(stmt)?;
            semi = false;
        }
        Statement::While(ref stmt) =&gt; {
            new_line = self.write_while_stmt(stmt)?;
            semi = false;
        }
        Statement::DoWhile(ref stmt) =&gt; self.write_do_while_stmt(stmt)?,
        Statement::For(ref stmt) =&gt; {
            self.at_top_level = false;
            new_line = self.write_for_stmt(stmt)?;
            semi = false;
        }
        Statement::ForIn(ref stmt) =&gt; {
            self.at_top_level = false;
            new_line = self.write_for_in_stmt(stmt)?;
            semi = false;
        }
        Statement::ForOf(ref stmt) =&gt; {
            self.at_top_level = false;
            new_line = self.write_for_of_stmt(stmt)?;
            semi = false;
        }
        Statement::Var(ref stmt) =&gt; self.write_var_stmt(stmt)?,
    };
    if semi {
        self.write_empty_stmt()?;
    }
    if new_line {
        self.write_new_line()?;
    }
    self.at_top_level = cached_state;
    Ok(())
}
#}</code></pre></pre>
<p>That is a pretty big match statement! Before we enter that we have a couple of context flags to help us with formatting <code>write_semi</code> and <code>new_line</code>, both with a default value of <code>true</code>. Looking at our example, we would enter the <code>Statement::Expr</code> arm of the match which handles handles the possible requirement that this statement be wrapped in parentheses. Primitive literals, object literals, functions, and binary operations would require parentheses when not part of a larger statement. There is a convenience method called <code>write_wrapped_expr</code> that just writes parentheses around a call to <code>write_expr</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn write_expr(&amp;mut self, expr: &amp;Expression) -&gt; Res {
    let cached_state = self.at_top_level;
    match expr {
        Expression::Literal(ref expr) =&gt; self.write_literal(expr)?,
        Expression::ThisExpression =&gt; self.write_this_expr()?,
        Expression::SuperExpression =&gt; self.write_super_expr()?,
        Expression::Array(ref expr) =&gt; self.write_array_expr(expr)?,
        Expression::Object(ref expr) =&gt; self.write_object_expr(expr)?,
        Expression::Function(ref expr) =&gt; {
            self.at_top_level = false;
            self.write_function(expr)?;
            self.at_top_level = cached_state;
        }
        Expression::Unary(ref expr) =&gt; self.write_unary_expr(expr)?,
        Expression::Update(ref expr) =&gt; self.write_update_expr(expr)?,
        Expression::Binary(ref expr) =&gt; self.write_binary_expr(expr)?,
        Expression::Assignment(ref expr) =&gt; {
            self.at_top_level = false;
            self.write_assignment_expr(expr)?
        },
        Expression::Logical(ref expr) =&gt; self.write_logical_expr(expr)?,
        Expression::Member(ref expr) =&gt; self.write_member_expr(expr)?,
        Expression::Conditional(ref expr) =&gt; self.write_conditional_expr(expr)?,
        Expression::Call(ref expr) =&gt; self.write_call_expr(expr)?,
        Expression::New(ref expr) =&gt; self.write_new_expr(expr)?,
        Expression::Sequence(ref expr) =&gt; self.write_sequence_expr(expr)?,
        Expression::Spread(ref expr) =&gt; self.write_spread_expr(expr)?,
        Expression::ArrowFunction(ref expr) =&gt; {
            self.at_top_level = false;
            self.write_arrow_function_expr(expr)?;
            self.at_top_level = cached_state;
        }
        Expression::Yield(ref expr) =&gt; self.write_yield_expr(expr)?,
        Expression::Class(ref expr) =&gt; {
            self.at_top_level = false;
            self.write_class(expr)?;
            self.at_top_level = cached_state;
        }
        Expression::MetaProperty(ref expr) =&gt; self.write_meta_property(expr)?,
        Expression::Await(ref expr) =&gt; self.write_await_expr(expr)?,
        Expression::Ident(ref expr) =&gt; self.write_ident(expr)?,
        Expression::TaggedTemplate(ref expr) =&gt; self.write_tagged_template(expr)?,
        _ =&gt; unreachable!(),
    }
    Ok(())
}
#}</code></pre></pre>
<p>The first step here is to keep a copy of the previous <code>at_top_level</code> flag so that we can revert back to it after writing, some of the arms are going to change it. Next we enter another very large match statement. Our example would take the <code>Expression::Assignment</code> arm, passing further work off to <code>write_assignment_expr</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn write_assignment_expr(&amp;mut self, assignment: &amp;AssignmentExpression) -&gt; Res {
    let wrap_self = match &amp;assignment.left {
        AssignmentLeft::Expr(ref e) =&gt; match &amp;**e {
            Expression::Object(_) 
            | Expression::Array(_) =&gt; true,
            _ =&gt; false,
        }, 
        AssignmentLeft::Pattern(ref p) =&gt; match p {
            Pattern::Array(_) =&gt; true,
            Pattern::Object(_) =&gt; true,
            _ =&gt; false,
        }
    };
    if wrap_self {
        self.write(&quot;(&quot;)?;
    }
    match &amp;assignment.left {
        AssignmentLeft::Expr(ref e) =&gt; self.write_expr(e)?,
        AssignmentLeft::Pattern(ref p) =&gt; self.write_pattern(p)?,
    }
    self.write(&quot; &quot;)?;
    self.write_assignment_operator(&amp;assignment.operator)?;
    self.write(&quot; &quot;)?;
    self.write_expr(&amp;assignment.right)?;
    if wrap_self {
        self.write(&quot;)&quot;)?;
    }
    Ok(())
}
#}</code></pre></pre>
<p>Here we are first we need to determine if the whole assignment expression needs to be wrapped in parentheses which would only be true if the left hand side was an object or array literal. Next we test the <code>assignment.left</code> property since it can be either an <code>Expression</code> or a <code>Pattern</code>, our example would take us back to the <code>write_expr</code> method. This would take us back up through <code>write_expr</code> but this time we would pass into the <code>Expression::Member</code> arm which passes its work off to <code>write_member_expr</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn write_member_expr(&amp;mut self, member: &amp;MemberExpression) -&gt; Res {
    match &amp;*member.object {
        Expression::Assignment(_) 
        | Expression::Literal(Literal::Number(_))
        | Expression::Conditional(_)
        | Expression::Logical(_) 
        | Expression::Function(_)
        | Expression::ArrowFunction(_)
        | Expression::Object(_)
        | Expression::Binary(_) 
        | Expression::Unary(_)
        | Expression::Update(_) =&gt; self.write_wrapped_expr(&amp;member.object)?,
        _ =&gt; self.write_expr(&amp;member.object)?,
    }
    if member.computed {
        self.write(&quot;[&quot;)?;
    } else {
        self.write(&quot;.&quot;)?;
    }
    self.write_expr(&amp;member.property)?;
    if member.computed {
        self.write(&quot;]&quot;)?;
    }
    Ok(())
}
#}</code></pre></pre>
<p>Here we first check to see if the <code>object</code> property is required to be wrapped in parentheses for us though we just want to pass that along to <code>write_expr</code>. This time though there we are going to end up at <code>Expression::ThisExpression</code> which just writes out the literal word <code>this</code>. Next we are going to look at the flag on <code>MemberExpression</code> &quot;computed&quot; to see if this was written originally with the bracket notation (<code>this['stuff']</code>) or the dot notation (<code>this.stuff</code>), writing the appropriate character. Now we are again going to pass some work back to <code>write_expr</code>, this time with the <code>property</code> property. This would end on the branch for <code>Expression::Ident</code> which just writes that value to the destination. If the member expression was computed we would need to write the <code>]</code> but for our example it is not.</p>
<p>At this point we are back up at <code>write_assignment_expr</code> where we are going to write a single space and then pass the <code>assignment.operator</code> off to <code>write_assignment_operator</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn write_assignment_operator(&amp;mut self, op: &amp;AssignmentOperator) -&gt; Res {
    let s = match op {
        AssignmentOperator::AndEqual =&gt; &quot;&amp;=&quot;,
        AssignmentOperator::DivEqual =&gt; &quot;/=&quot;,
        AssignmentOperator::Equal =&gt; &quot;=&quot;,
        AssignmentOperator::LeftShiftEqual =&gt; &quot;&lt;&lt;=&quot;,
        AssignmentOperator::MinusEqual =&gt; &quot;-=&quot;,
        AssignmentOperator::ModEqual =&gt; &quot;%=&quot;,
        AssignmentOperator::OrEqual =&gt; &quot;|=&quot;,
        AssignmentOperator::PlusEqual =&gt; &quot;+=&quot;,
        AssignmentOperator::PowerOfEqual =&gt; &quot;**=&quot;,
        AssignmentOperator::RightShiftEqual =&gt; &quot;&gt;&gt;=&quot;,
        AssignmentOperator::TimesEqual =&gt; &quot;*=&quot;,
        AssignmentOperator::UnsignedRightShiftEqual =&gt; &quot;&gt;&gt;&gt;=&quot;,
        AssignmentOperator::XOrEqual =&gt; &quot;^=&quot;,
    };
    self.write(s)?;
    Ok(())
}
#}</code></pre></pre>
<p>This is a relatively straight forward process of looking at which operator was provided and then writing out the text that represents that operator. For our example it would be <code>=</code>, we then need to write a single space. The last step in <code>write_assignment_expr</code> is to handle the <code>assignment.right</code> which is also an <code>Expression</code> so we pass that off to <code>write_expr</code>. Our example will head to the <code>Expression::Ident</code> match arm and then just write to the destination. With that we have now reached the last step in <code>write_function_body</code> which is to <code>write_close_brace</code> similar to <code>write_open_brace</code> here we are decrementing the <code>current_indent</code> context property. That also brings us to the end of <code>write_function</code>, <code>write_decl</code>, and <code>_write_part</code>. The last thing we do in <code>write_part</code> is to add a trailing new line, another style choice.</p>
<p>As our example continues we would then start again at <code>write_part</code> with the next part. This is going to move though <code>_write_part</code> the same as before, however when we get to <code>write_decl</code> we have a new branch to head down. This is the <code>Decl::Variable</code> arm which passes its work off to <code>write_variable_decls</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn write_variable_decls(&amp;mut self, kind: &amp;VariableKind, decls: &amp;[VariableDecl]) -&gt; Res {
    self.write_variable_kind(kind)?;
    let mut after_first = false;
    for decl in decls {
        if after_first {
            self.write(&quot;, &quot;)?;
        } else {
            after_first = true;
        }
        self.write_variable_decl(decl)?;
    }
    self.write_empty_stmt()?;
    self.write_new_line()
}
#}</code></pre></pre>
<p>As you might expect the first thing we want to do is to write the variable kind. We pass off the <code>kind</code> variable to <code>write_variable_kind</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn write_variable_kind(&amp;mut self, kind: &amp;VariableKind) -&gt; Res {
    let s = match kind {
        VariableKind::Const =&gt; &quot;const &quot;,
        VariableKind::Let =&gt; &quot;let &quot;,
        VariableKind::Var =&gt; &quot;var &quot;,
    };
    self.write(s)
}
#}</code></pre></pre>
<p>Similar to our examination of <code>write_assignment_operator</code> we are going to simply look at which keyword was used and then write that out, with a trailing space.</p>
<p>Next we need to keep track of two flags <code>after_first</code> which should be familiar from <code>write_function_args</code>. In our loop, we pass of each of the declarations to <code>write_variable_decl</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn write_variable_decl(&amp;mut self, decl: &amp;VariableDecl) -&gt; Res {
    self.write_pattern(&amp;decl.id)?;
    if let Some(ref init) = decl.init {
        self.write(&quot; = &quot;)?;
        self.write_expr(init)?;
    }
    Ok(())
}
#}</code></pre></pre>
<p>Here we first write out the id of this variable by passing it off to <code>write_pattern</code>. Thankfully our example is pretty simple so we are again going to take that first branch for <code>Pattern::Ident</code> and write the identifer to our destination. After that we want to check if this variable is initialized, ours is, and if so we would write the &quot; = &quot; and then write the expression by passing that off to <code>write_expr</code>. For this pass through <code>write_expr</code> we are going to travel down the <code>Expression::New</code> arm which passes its work off to <code>write_new_expr</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn write_new_expr(&amp;mut self, new: &amp;NewExpression) -&gt; Res {
    self.write(&quot;new &quot;)?;
    match &amp;*new.callee {
        Expression::Assignment(_) 
        | Expression::Call(_) =&gt; self.write_wrapped_expr(&amp;new.callee)?,
        _ =&gt; self.write_expr(&amp;new.callee)?,
    }
    self.write_sequence_expr(&amp;new.arguments)?;
    Ok(())
}
#}</code></pre></pre>
<p>At this point we want to first write the <code>new</code> keyword followed by a space. Next we want to write out what the <code>new.callee</code> is which would again bring us to <code>write_expr</code>. Our example would travel to the <code>Expression::Ident</code> arm which just writes that out. Next we need to write an open parenthesis followed by the provided arguments. This time we are going to use the <code>write_sequence_expr</code> method to do that.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn write_sequence_expr(&amp;mut self, sequence: &amp;[Expression]) -&gt; Res {
    let mut after_first = false;
    self.write(&quot;(&quot;)?;
    for ref e in sequence {
        if after_first {
            self.write(&quot;, &quot;)?;
        }
        self.write_expr(e)?;
        after_first = true;
    }
    self.write(&quot;)&quot;)?;
    Ok(())
}
#}</code></pre></pre>
<p>At this point the structure of this function's body should look familiar, we are going to loop over the provide expressions and write them out with a comma and space before all but the first one. For our example we are going only hit this once so no comma, then we are going to pass that off to <code>write_expr</code>. This time as we pass through the match in <code>write_expr</code> we are going to hit the <code>Expression::Literal</code> arm which passes its work off to <code>write_literal</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn write_literal(&amp;mut self, lit: &amp;Literal) -&gt; Res {
    match lit {
        Literal::Boolean(b) =&gt; self.write_bool(*b),
        Literal::Null =&gt; self.write(&quot;null&quot;),
        Literal::Number(n) =&gt; self.write(&amp;n),
        Literal::String(s) =&gt; self.write_string(s),
        Literal::RegEx(r) =&gt; self.write_regex(r),
        Literal::Template(t) =&gt; self.write_template(t),
    }
}
#}</code></pre></pre>
<p>Here we see another match statement, our example will take us down the <code>Literal::String</code> arm which passes off work to <code>write_string</code>. You may be wondering why that is, since writing strings is all we have really been doing. The answer is that this is one of the few style preferences that is currently configurable as you'll see.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn write_string(&amp;mut self, s: &amp;str) -&gt; Res {
    if let Some(c) = self.quote {
        self.re_write_string(s, c)?;
    } else {
        self.write(s)?;
    }
    Ok(())
}
#}</code></pre></pre>
<p>We first check to see if the <code>self.quote</code> property has been set, this would indicate that the user has a quote preference. If it is set then we want to re-write the string to use this quote, this involves re-writing any internal escaped quotes for the old quote and escaping the new quote that might appear in the contents. If that property is <code>None</code> then we would just write it out normally as the <code>ressa::node::Literal::String</code> preserves the original quotation mark.</p>
<p>After that we are again back at <code>write_new_expr</code> where the last thing to do is write the closing parenthesis, after which we are at the bottom of <code>write_variable_decl</code>. When we move up again to the <code>write_variable_decls</code> we would write a semi-colon and new line to close that out. This brings us to the bottom of <code>write_decl</code>, <code>_write_part</code>, and <code>write_part</code>, it also brings us to the end of our example JavaScript. While we didn't touch every part of how <code>resw</code> works, there is a lot of surface area to cover, hopefully it has provided enough information for you feel confident in how it works. For more information you can check out the <a href="https://docs.rs/ressa/"><code>ressa</code> docs</a> and the <a href="https://docs.rs/resw/"><code>resw</code> docs</a>.</p>
<p>Up next we are going to see how you would use <code>resw</code> to complete our debug log helper.</p>
<!--web-only-end-->
<!--slides-only-->
<ul>
<li><code>Writer</code> takes <code>ProgramPart</code>s</li>
<li>Somewhat Configurable</li>
<li>Writes to <code>impl Write</code></li>
</ul>
<!--slides-only-->
<script>var PresentationMode;!function(e){e[e.Slides=0]="Slides",e[e.Web=1]="Web"}(PresentationMode||(PresentationMode={}));var PresentationModeHider=function(){function e(){var t=this;(this.queryKey="presentation_mode",this.webClass="article-content",this.preClass="presentation-only",this.mode=this.getMode(),this.setMode(),this.assignClassesViaComments(),this.mode!==PresentationMode.Slides||""!==location.pathname&&"/"!==location.pathname)||document.querySelector(".sidebar > .chapter").firstChild.firstChild.click();window.addEventListener("keyup",function(e){e.altKey&&("p"!=e.key&&"P"!=e.key&&"KeyP"!=e.code||t.toggle())})}return e.prototype.assignClassesViaComments=function(){for(var e,t=document.createNodeIterator(document.body,NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_COMMENT,null),n=this.mode===PresentationMode.Web?"not-presenting":"presenting",o=null;e=t.nextNode();)if(8===e.nodeType){var s=e.nodeValue.trim();o="web-only"===s?this.webClass:"slides-only"===s?this.preClass:null}else 1===e.nodeType&&null!==o&&e.classList.add(o,n)},e.prototype.getMode=function(){var t=localStorage.getItem(this.queryKey);if(null===t)return PresentationMode.Web;try{var e=parseInt(t);return 1<e||e<0?(console.error("presentation_mode was out of range",e),PresentationMode.Web):e}catch(e){return console.error("presentation_mode present in localStorage but value is not an integer",t,e),PresentationMode.Web}},e.prototype.setMode=function(){localStorage.setItem(this.queryKey,this.mode.toString())},e.prototype.updatePage=function(){this.updateElements(document.querySelectorAll(".presentation-only")),this.updateElements(document.querySelectorAll(".article-content"))},e.prototype.updateElements=function(e){for(var t=0;t<e.length;t++){var n=e[t];this.mode===PresentationMode.Slides?n.classList.replace("not-presenting","presenting"):n.classList.replace("presenting","not-presenting")}},e.prototype.toggle=function(){switch(this.mode){case PresentationMode.Slides:this.mode=PresentationMode.Web;break;case PresentationMode.Web:this.mode=PresentationMode.Slides}this.setMode(),this.updatePage()},e}(),___presentationModeHider=new PresentationModeHider;</script><style>.presentation-only.not-presenting{display:none}.article-content.presenting{display:none}
</style>
<a class="header" href="#building-a-writer" id="building-a-writer"><h1>Building a Writer</h1></a>
<!--web-only-->
<p>Thankfully because of the existence of <code>resw</code> completing the <code>console.log</code> debugging tool is going to be trivial. The primary entry point for <code>resw</code> is the <code>Writer</code> struct, which has a method <code>write_part</code> that will take a <code>&amp;mut self</code> and <code>&amp;ProgramPart</code>, so we can use that in our for loop to write out the parts as they are parsed. That might look like this.</p>
<pre><pre class="playpen"><code class="language-rust">use resw::Writer;
fn main() {
    let js = get_js().expect(&quot;Unable to get JavaScript&quot;);
    let parser = Parser::new(&amp;js).expect(&quot;Unable to construct parser&quot;);
    let mut writer = Writer::new(::std::io::stdout());
    for part in parser.filter_map(|p| p.ok()).map(map_part) {
        writer.write_part(&amp;part).expect(&quot;Failed to write part&quot;);
    }
}
</code></pre></pre>
<p>With that complete we can see how well it works for us. Let's use the following example JavaScript.</p>
<pre><code class="language-js">function Thing(stuff) {
    this.stuff = stuff;
}
let x = new Thing('argument');
</code></pre>
<p>Just as a simple test we could enter the following into our terminal</p>
<pre><code class="language-bash">$ echo &quot;function Thing(stuff) {
    this.stuff = stuff;
}
let x = new Thing('argument');
&quot; | console_logify
function Thing(stuff) {
    console.log('Thing', stuff);
    this.stuff = stuff;
}

let x = new Thing('argument!');
</code></pre>
<p>That looks exactly like the output we were looking for. Let's double check that it will behave as expected by piping the output to <code>node</code></p>
<pre><code class="language-bash">$ echo &quot;function Thing(stuff) {
    this.stuff = stuff;
}
let x = new Thing('argument');
&quot; | console_logify | node -
Thing argument
</code></pre>
<p>It worked!</p>
<!--web-only-end-->
<!--slides-only-->
<a class="header" href="#demo-2" id="demo-2"><h2>Demo</h2></a>
<!--slides-only-end-->
<script>var PresentationMode;!function(e){e[e.Slides=0]="Slides",e[e.Web=1]="Web"}(PresentationMode||(PresentationMode={}));var PresentationModeHider=function(){function e(){var t=this;(this.queryKey="presentation_mode",this.webClass="article-content",this.preClass="presentation-only",this.mode=this.getMode(),this.setMode(),this.assignClassesViaComments(),this.mode!==PresentationMode.Slides||""!==location.pathname&&"/"!==location.pathname)||document.querySelector(".sidebar > .chapter").firstChild.firstChild.click();window.addEventListener("keyup",function(e){e.altKey&&("p"!=e.key&&"P"!=e.key&&"KeyP"!=e.code||t.toggle())})}return e.prototype.assignClassesViaComments=function(){for(var e,t=document.createNodeIterator(document.body,NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_COMMENT,null),n=this.mode===PresentationMode.Web?"not-presenting":"presenting",o=null;e=t.nextNode();)if(8===e.nodeType){var s=e.nodeValue.trim();o="web-only"===s?this.webClass:"slides-only"===s?this.preClass:null}else 1===e.nodeType&&null!==o&&e.classList.add(o,n)},e.prototype.getMode=function(){var t=localStorage.getItem(this.queryKey);if(null===t)return PresentationMode.Web;try{var e=parseInt(t);return 1<e||e<0?(console.error("presentation_mode was out of range",e),PresentationMode.Web):e}catch(e){return console.error("presentation_mode present in localStorage but value is not an integer",t,e),PresentationMode.Web}},e.prototype.setMode=function(){localStorage.setItem(this.queryKey,this.mode.toString())},e.prototype.updatePage=function(){this.updateElements(document.querySelectorAll(".presentation-only")),this.updateElements(document.querySelectorAll(".article-content"))},e.prototype.updateElements=function(e){for(var t=0;t<e.length;t++){var n=e[t];this.mode===PresentationMode.Slides?n.classList.replace("not-presenting","presenting"):n.classList.replace("presenting","not-presenting")}},e.prototype.toggle=function(){switch(this.mode){case PresentationMode.Slides:this.mode=PresentationMode.Web;break;case PresentationMode.Web:this.mode=PresentationMode.Slides}this.setMode(),this.updatePage()},e}(),___presentationModeHider=new PresentationModeHider;</script><style>.presentation-only.not-presenting{display:none}.article-content.presenting{display:none}
</style>
<a class="header" href="#conclusion" id="conclusion"><h1>Conclusion</h1></a>
<!--web-only-->
<p>Hopefully now you have the all you to get started building your JavaScript development tools using Rust. If you do create one please open an issue on this project's <a href="https://github.com/FreeMasen/rusty-ecma-book/issues">GitHub issues</a> page with the project's name, a short description, and a link, and it will be added to the <a href="/a.appendix/projects.html">appendix</a>.</p>
<p>If you run into any problems in any crates (including typos in this book) it would be wonderful of you to open an issue on GitHub.</p>
<ul>
<li><a href="https://github.com/FreeMasen/RESS/issues"><code>ress</code> issues</a></li>
<li><a href="https://github.com/FreeMasen/RESSA/issues"><code>ressa</code> issues</a></li>
<li><a href="https://github.com/FreeMasen/RESW/issues"><code>resw</code> issues</a></li>
</ul>
<p>If you want to get involved, there are probably a few open issues that could use some help. Each project does provide contributing guidelines.</p>
<ul>
<li><a href="https://github.com/FreeMasen/RESSA/blob/master/CONTRIBUTING.md"><code>ress</code> contributions</a></li>
<li><a href="https://github.com/FreeMasen/RESSA/blob/master/CONTRIBUTING.md"><code>ressa</code> contributions</a></li>
<li><a href="https://github.com/FreeMasen/RESW#contributing"><code>resw</code> contributions</a></li>
</ul>
<!--web-only-end-->
<!--slides-only-->
<ul>
<li>Annotated version of this presentation
<ul>
<li>https://FreeMasen.github.io/rusty-ecma-book</li>
</ul>
</li>
<li>Where to find me
<ul>
<li>email: r.f.masen@gmail.com</li>
<li>website: https://WiredForge.com</li>
<li>twitter/github: @FreeMasen</li>
</ul>
</li>
</ul>
<!--slides-only-end-->
<script>var PresentationMode;!function(e){e[e.Slides=0]="Slides",e[e.Web=1]="Web"}(PresentationMode||(PresentationMode={}));var PresentationModeHider=function(){function e(){var t=this;(this.queryKey="presentation_mode",this.webClass="article-content",this.preClass="presentation-only",this.mode=this.getMode(),this.setMode(),this.assignClassesViaComments(),this.mode!==PresentationMode.Slides||""!==location.pathname&&"/"!==location.pathname)||document.querySelector(".sidebar > .chapter").firstChild.firstChild.click();window.addEventListener("keyup",function(e){e.altKey&&("p"!=e.key&&"P"!=e.key&&"KeyP"!=e.code||t.toggle())})}return e.prototype.assignClassesViaComments=function(){for(var e,t=document.createNodeIterator(document.body,NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_COMMENT,null),n=this.mode===PresentationMode.Web?"not-presenting":"presenting",o=null;e=t.nextNode();)if(8===e.nodeType){var s=e.nodeValue.trim();o="web-only"===s?this.webClass:"slides-only"===s?this.preClass:null}else 1===e.nodeType&&null!==o&&e.classList.add(o,n)},e.prototype.getMode=function(){var t=localStorage.getItem(this.queryKey);if(null===t)return PresentationMode.Web;try{var e=parseInt(t);return 1<e||e<0?(console.error("presentation_mode was out of range",e),PresentationMode.Web):e}catch(e){return console.error("presentation_mode present in localStorage but value is not an integer",t,e),PresentationMode.Web}},e.prototype.setMode=function(){localStorage.setItem(this.queryKey,this.mode.toString())},e.prototype.updatePage=function(){this.updateElements(document.querySelectorAll(".presentation-only")),this.updateElements(document.querySelectorAll(".article-content"))},e.prototype.updateElements=function(e){for(var t=0;t<e.length;t++){var n=e[t];this.mode===PresentationMode.Slides?n.classList.replace("not-presenting","presenting"):n.classList.replace("presenting","not-presenting")}},e.prototype.toggle=function(){switch(this.mode){case PresentationMode.Slides:this.mode=PresentationMode.Web;break;case PresentationMode.Web:this.mode=PresentationMode.Slides}this.setMode(),this.updatePage()},e}(),___presentationModeHider=new PresentationModeHider;</script><style>.presentation-only.not-presenting{display:none}.article-content.presenting{display:none}
</style>
<a class="header" href="#appendix" id="appendix"><h1>Appendix</h1></a>
<ol>
<li><a href="./tokens.html">Tokens</a></li>
<li><a href="./ie-8-banned.html">banned_tokens.toml</a></li>
<li><a href="./a.appendix/ast.html">AST</a></li>
<li><a href="./a.appendix/string.writer.html">StringWriter</a></li>
<li><a href="./a.appendix/projects.html">Projects</a></li>
</ol>
<script>var PresentationMode;!function(e){e[e.Slides=0]="Slides",e[e.Web=1]="Web"}(PresentationMode||(PresentationMode={}));var PresentationModeHider=function(){function e(){var t=this;(this.queryKey="presentation_mode",this.webClass="article-content",this.preClass="presentation-only",this.mode=this.getMode(),this.setMode(),this.assignClassesViaComments(),this.mode!==PresentationMode.Slides||""!==location.pathname&&"/"!==location.pathname)||document.querySelector(".sidebar > .chapter").firstChild.firstChild.click();window.addEventListener("keyup",function(e){e.altKey&&("p"!=e.key&&"P"!=e.key&&"KeyP"!=e.code||t.toggle())})}return e.prototype.assignClassesViaComments=function(){for(var e,t=document.createNodeIterator(document.body,NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_COMMENT,null),n=this.mode===PresentationMode.Web?"not-presenting":"presenting",o=null;e=t.nextNode();)if(8===e.nodeType){var s=e.nodeValue.trim();o="web-only"===s?this.webClass:"slides-only"===s?this.preClass:null}else 1===e.nodeType&&null!==o&&e.classList.add(o,n)},e.prototype.getMode=function(){var t=localStorage.getItem(this.queryKey);if(null===t)return PresentationMode.Web;try{var e=parseInt(t);return 1<e||e<0?(console.error("presentation_mode was out of range",e),PresentationMode.Web):e}catch(e){return console.error("presentation_mode present in localStorage but value is not an integer",t,e),PresentationMode.Web}},e.prototype.setMode=function(){localStorage.setItem(this.queryKey,this.mode.toString())},e.prototype.updatePage=function(){this.updateElements(document.querySelectorAll(".presentation-only")),this.updateElements(document.querySelectorAll(".article-content"))},e.prototype.updateElements=function(e){for(var t=0;t<e.length;t++){var n=e[t];this.mode===PresentationMode.Slides?n.classList.replace("not-presenting","presenting"):n.classList.replace("presenting","not-presenting")}},e.prototype.toggle=function(){switch(this.mode){case PresentationMode.Slides:this.mode=PresentationMode.Web;break;case PresentationMode.Web:this.mode=PresentationMode.Slides}this.setMode(),this.updatePage()},e}(),___presentationModeHider=new PresentationModeHider;</script><style>.presentation-only.not-presenting{display:none}.article-content.presenting{display:none}
</style>
<a class="header" href="#tokens" id="tokens"><h1>Tokens</h1></a>
<p>Here is a list of all of the possible tokens <code>ress</code> provides</p>
<ul>
<li><code>Token</code>
<ul>
<li><code>EoF</code></li>
<li><code>Boolean</code> - <code>enum BooleanLiteral</code>
<ul>
<li><code>True</code></li>
<li><code>False</code></li>
</ul>
</li>
<li><code>Ident</code> - <code>struct Ident(String)</code></li>
<li><code>Keyword</code> - <code>enum Keyword</code>
<ul>
<li><code>Await</code></li>
<li><code>Break</code></li>
<li><code>Case</code></li>
<li><code>Catch</code></li>
<li><code>Class</code></li>
<li><code>Const</code></li>
<li><code>Continue</code></li>
<li><code>Debugger</code></li>
<li><code>Default</code></li>
<li><code>Delete</code></li>
<li><code>Do</code></li>
<li><code>Else</code></li>
<li><code>Enum</code></li>
<li><code>Export</code></li>
<li><code>Finally</code></li>
<li><code>For</code></li>
<li><code>Function</code></li>
<li><code>If</code></li>
<li><code>Implements</code></li>
<li><code>Import</code></li>
<li><code>In</code></li>
<li><code>InstanceOf</code></li>
<li><code>Interface</code></li>
<li><code>Let</code></li>
<li><code>New</code></li>
<li><code>Package</code></li>
<li><code>Private</code></li>
<li><code>Protected</code></li>
<li><code>Public</code></li>
<li><code>Return</code></li>
<li><code>Static</code></li>
<li><code>Super</code></li>
<li><code>Switch</code></li>
<li><code>This</code></li>
<li><code>Throw</code></li>
<li><code>Try</code></li>
<li><code>TypeOf</code></li>
<li><code>Var</code></li>
<li><code>Void</code></li>
<li><code>While</code></li>
<li><code>With</code></li>
<li><code>Yield</code></li>
</ul>
</li>
<li><code>Null</code></li>
<li><code>Numeric</code> - <code>struct Number(String)</code>
<ul>
<li><code>0</code></li>
<li><code>.0</code></li>
<li><code>0.0</code></li>
<li><code>0.0e1</code></li>
<li><code>0.0E1</code></li>
<li><code>.0e1</code></li>
<li><code>.0E1</code></li>
<li><code>0xfff</code></li>
<li><code>0Xfff</code></li>
<li><code>0o777</code></li>
<li><code>0O777</code></li>
<li><code>0b111</code></li>
<li><code>0B111</code></li>
</ul>
</li>
<li><code>Punct</code> - <code>enum Punct</code>
<ul>
<li><code>And</code> - <code>&amp;</code></li>
<li><code>Assign</code> - <code>=</code></li>
<li><code>Asterisk</code> - <code>*</code></li>
<li><code>BitwiseNot</code> - <code>~</code></li>
<li><code>Caret</code> - <code>^</code></li>
<li><code>CloseBrace</code> - <code>}</code></li>
<li><code>CloseBracket</code> - <code>]</code></li>
<li><code>CloseParen</code> - <code>)</code></li>
<li><code>Colon</code> - <code>:</code></li>
<li><code>Comma</code> - <code>,</code></li>
<li><code>ForwardSlash</code> - <code>/</code></li>
<li><code>GreaterThan</code> - <code>&gt;</code></li>
<li><code>LessThan</code> - <code>&lt;</code></li>
<li><code>Minus</code> - <code>-</code></li>
<li><code>Modulo</code> - <code>%</code></li>
<li><code>Not</code> - <code>!</code></li>
<li><code>OpenBrace</code> - <code>{</code></li>
<li><code>OpenBracket</code> - <code>[</code></li>
<li><code>OpenParen</code> - <code>(</code></li>
<li><code>Period</code> - <code>.</code></li>
<li><code>Pipe</code> - <code>|</code></li>
<li><code>Plus</code> - <code>+</code></li>
<li><code>QuestionMark</code> - <code>?</code></li>
<li><code>SemiColon</code> - <code>;</code></li>
<li><code>Spread</code> - <code>...</code></li>
<li><code>UnsignedRightShiftAssign</code> - <code>&gt;&gt;&gt;=</code></li>
<li><code>StrictEquals</code> - <code>===</code></li>
<li><code>StrictNotEquals</code> - <code>!==</code></li>
<li><code>UnsignedRightShift</code> - <code>&gt;&gt;&gt;</code></li>
<li><code>LeftShiftAssign</code> - <code>&lt;&lt;=</code></li>
<li><code>RightShiftAssign</code> - <code>&gt;&gt;=</code></li>
<li><code>ExponentAssign</code> - <code>**=</code></li>
<li><code>LogicalAnd</code> - <code>&amp;&amp;</code></li>
<li><code>LogicalOr</code> - <code>||</code></li>
<li><code>Equal</code> - <code>==</code></li>
<li><code>NotEqual</code> - <code>!=</code></li>
<li><code>AddAssign</code> - <code>+=</code></li>
<li><code>SubtractAssign</code> - <code>-=</code></li>
<li><code>MultiplyAssign</code> - <code>*=</code></li>
<li><code>DivideAssign</code> - <code>/=</code></li>
<li><code>Increment</code> - <code>++</code></li>
<li><code>Decrement</code> - <code>--</code></li>
<li><code>LeftShift</code> - <code>&lt;&lt;</code></li>
<li><code>RightShift</code> - <code>&gt;&gt;</code></li>
<li><code>BitwiseAndAssign</code> - <code>&amp;=</code></li>
<li><code>BitwiseOrAssign</code> - <code>|=</code></li>
<li><code>BitwiseXOrAssign</code> - <code>^=</code></li>
<li><code>ModuloAssign</code> - <code>%=</code></li>
<li><code>FatArrow</code> - <code>=&gt;</code></li>
<li><code>GreaterThanEqual</code> - <code>&gt;=</code></li>
<li><code>LessThanEqual</code> - `&lt;=</li>
<li><code>Exponent</code> - <code>**</code></li>
</ul>
</li>
<li><code>String</code> - <code>enum StringLit</code>
<ul>
<li><code>Single(String)</code></li>
<li><code>Double(String)</code></li>
</ul>
</li>
<li><code>Regex</code> - <code>struct Regex</code>
<ul>
<li><code>body</code> - <code>String</code></li>
<li><code>flags</code> - <code>Option&lt;String&gt;</code></li>
</ul>
</li>
<li><code>Template</code> - <code>enum Template</code>,
<ul>
<li><code>NoSub(String)</code></li>
<li><code>Head(String)</code></li>
<li><code>Middle(String)</code></li>
<li><code>Tail(String)</code></li>
</ul>
</li>
<li><code>Comment</code> - <code>struct Comment</code>
<ul>
<li><code>kind</code> - <code>enum Kind</code>
<ul>
<li><code>Single</code> - <code>//comment</code></li>
<li><code>Multi</code> - <code>/* comment */</code></li>
<li><code>Html</code> - <code>&lt;!-- comment --&gt; trailing content</code></li>
</ul>
</li>
<li><code>content</code> - <code>String</code></li>
<li><code>tail_content</code> - <code>Option&lt;String&gt;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<script>var PresentationMode;!function(e){e[e.Slides=0]="Slides",e[e.Web=1]="Web"}(PresentationMode||(PresentationMode={}));var PresentationModeHider=function(){function e(){var t=this;(this.queryKey="presentation_mode",this.webClass="article-content",this.preClass="presentation-only",this.mode=this.getMode(),this.setMode(),this.assignClassesViaComments(),this.mode!==PresentationMode.Slides||""!==location.pathname&&"/"!==location.pathname)||document.querySelector(".sidebar > .chapter").firstChild.firstChild.click();window.addEventListener("keyup",function(e){e.altKey&&("p"!=e.key&&"P"!=e.key&&"KeyP"!=e.code||t.toggle())})}return e.prototype.assignClassesViaComments=function(){for(var e,t=document.createNodeIterator(document.body,NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_COMMENT,null),n=this.mode===PresentationMode.Web?"not-presenting":"presenting",o=null;e=t.nextNode();)if(8===e.nodeType){var s=e.nodeValue.trim();o="web-only"===s?this.webClass:"slides-only"===s?this.preClass:null}else 1===e.nodeType&&null!==o&&e.classList.add(o,n)},e.prototype.getMode=function(){var t=localStorage.getItem(this.queryKey);if(null===t)return PresentationMode.Web;try{var e=parseInt(t);return 1<e||e<0?(console.error("presentation_mode was out of range",e),PresentationMode.Web):e}catch(e){return console.error("presentation_mode present in localStorage but value is not an integer",t,e),PresentationMode.Web}},e.prototype.setMode=function(){localStorage.setItem(this.queryKey,this.mode.toString())},e.prototype.updatePage=function(){this.updateElements(document.querySelectorAll(".presentation-only")),this.updateElements(document.querySelectorAll(".article-content"))},e.prototype.updateElements=function(e){for(var t=0;t<e.length;t++){var n=e[t];this.mode===PresentationMode.Slides?n.classList.replace("not-presenting","presenting"):n.classList.replace("presenting","not-presenting")}},e.prototype.toggle=function(){switch(this.mode){case PresentationMode.Slides:this.mode=PresentationMode.Web;break;case PresentationMode.Web:this.mode=PresentationMode.Slides}this.setMode(),this.updatePage()},e}(),___presentationModeHider=new PresentationModeHider;</script><style>.presentation-only.not-presenting{display:none}.article-content.presenting{display:none}
</style>
<a class="header" href="#banned_tokenstoml" id="banned_tokenstoml"><h1>banned_tokens.toml</h1></a>
<pre><code class="language-toml">idents = [
    &quot;Int8Array&quot;,
    &quot;Uint8Array&quot;,
    &quot;Uint8ClampedArray&quot;,
    &quot;Int16Array&quot;,
    &quot;Uint16Array&quot;,
    &quot;Int32Array&quot;,
    &quot;Uint32Array&quot;,
    &quot;Float32Array&quot;,
    &quot;Float64Array&quot;,
    &quot;Promise&quot;,
    &quot;Proxy&quot;,
    &quot;async&quot;,
    &quot;padStart&quot;,
    &quot;padEnd&quot;,
    &quot;includes&quot;,
    &quot;find&quot;,
    &quot;getComputedStyle&quot;,
    &quot;FontFace&quot;,
    &quot;FontFaceSet&quot;,
    &quot;FontFaceSetLoadEvent&quot;,
    &quot;MediaSource&quot;,
    &quot;sourceBuffers&quot;,
    &quot;activeSourceBuffers&quot;,
    &quot;readyState&quot;,
    &quot;duration&quot;,
    &quot;onsourceclose&quot;,
    &quot;onsourceended&quot;,
    &quot;addSourceBuffer&quot;,
    &quot;removeSourceBuffer&quot;,
    &quot;endOfStream&quot;,
    &quot;setLiveSeekableRange&quot;,
    &quot;clearLiveSeekableRange&quot;,
    &quot;isTypeSupported&quot;,
    &quot;TouchEvent&quot;,
    &quot;Touch&quot;,
    &quot;TouchList&quot;,
    &quot;onpointerover&quot;,
    &quot;onpointerenter&quot;,
    &quot;onpointerdown&quot;,
    &quot;onpointermove&quot;,
    &quot;onpointerup&quot;,
    &quot;onpointercancel&quot;,
    &quot;onpointerout&quot;,
    &quot;onpointerleave&quot;,
    &quot;ongotpointercapture&quot;,
    &quot;onlostpointercapture&quot;,
    &quot;setPointerCapture&quot;,
    &quot;releasePointerCapture&quot;,
    &quot;MutationObserver&quot;,
]
keywords = [
    &quot;let&quot;,
    &quot;const&quot;,
    &quot;class&quot;,
    &quot;await&quot;,
    &quot;import&quot;,
    &quot;export&quot;,
    &quot;yield&quot;,
]
puncts = [
    &quot;=&gt;&quot;,
    &quot;**&quot;,
    &quot;...&quot;,
    &quot;`&quot;,
]
strings = [
    &quot;use strict&quot;,
    &quot;sourceopen&quot;,
    &quot;touchstart&quot;,
    &quot;touchend&quot;,
    &quot;touchmove&quot;,
    &quot;touchcancel&quot;,
    &quot;pointerenter&quot;,
    &quot;pointerdown&quot;,
    &quot;pointermove&quot;,
    &quot;pointerup&quot;,
    &quot;pointercancel&quot;,
    &quot;pointerout&quot;,
    &quot;pointerleave&quot;,
    &quot;gotpointercapture&quot;,
    &quot;lostpointercapture&quot;,
    &quot;pointerover&quot;,
]
</code></pre>
<script>var PresentationMode;!function(e){e[e.Slides=0]="Slides",e[e.Web=1]="Web"}(PresentationMode||(PresentationMode={}));var PresentationModeHider=function(){function e(){var t=this;(this.queryKey="presentation_mode",this.webClass="article-content",this.preClass="presentation-only",this.mode=this.getMode(),this.setMode(),this.assignClassesViaComments(),this.mode!==PresentationMode.Slides||""!==location.pathname&&"/"!==location.pathname)||document.querySelector(".sidebar > .chapter").firstChild.firstChild.click();window.addEventListener("keyup",function(e){e.altKey&&("p"!=e.key&&"P"!=e.key&&"KeyP"!=e.code||t.toggle())})}return e.prototype.assignClassesViaComments=function(){for(var e,t=document.createNodeIterator(document.body,NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_COMMENT,null),n=this.mode===PresentationMode.Web?"not-presenting":"presenting",o=null;e=t.nextNode();)if(8===e.nodeType){var s=e.nodeValue.trim();o="web-only"===s?this.webClass:"slides-only"===s?this.preClass:null}else 1===e.nodeType&&null!==o&&e.classList.add(o,n)},e.prototype.getMode=function(){var t=localStorage.getItem(this.queryKey);if(null===t)return PresentationMode.Web;try{var e=parseInt(t);return 1<e||e<0?(console.error("presentation_mode was out of range",e),PresentationMode.Web):e}catch(e){return console.error("presentation_mode present in localStorage but value is not an integer",t,e),PresentationMode.Web}},e.prototype.setMode=function(){localStorage.setItem(this.queryKey,this.mode.toString())},e.prototype.updatePage=function(){this.updateElements(document.querySelectorAll(".presentation-only")),this.updateElements(document.querySelectorAll(".article-content"))},e.prototype.updateElements=function(e){for(var t=0;t<e.length;t++){var n=e[t];this.mode===PresentationMode.Slides?n.classList.replace("not-presenting","presenting"):n.classList.replace("presenting","not-presenting")}},e.prototype.toggle=function(){switch(this.mode){case PresentationMode.Slides:this.mode=PresentationMode.Web;break;case PresentationMode.Web:this.mode=PresentationMode.Slides}this.setMode(),this.updatePage()},e}(),___presentationModeHider=new PresentationModeHider;</script><style>.presentation-only.not-presenting{display:none}.article-content.presenting{display:none}
</style>
<a class="header" href="#ast" id="ast"><h1>AST</h1></a>
<p>While it may be a bit of a cop-out, it seems silly to duplicate the AST docs provided by cargo-doc. In the future this page may include some more introspective information but for now please refer to the link below.</p>
<p><a href="https://docs.rs/ressa/"><code>ressa</code> docs</a></p>
<script>var PresentationMode;!function(e){e[e.Slides=0]="Slides",e[e.Web=1]="Web"}(PresentationMode||(PresentationMode={}));var PresentationModeHider=function(){function e(){var t=this;(this.queryKey="presentation_mode",this.webClass="article-content",this.preClass="presentation-only",this.mode=this.getMode(),this.setMode(),this.assignClassesViaComments(),this.mode!==PresentationMode.Slides||""!==location.pathname&&"/"!==location.pathname)||document.querySelector(".sidebar > .chapter").firstChild.firstChild.click();window.addEventListener("keyup",function(e){e.altKey&&("p"!=e.key&&"P"!=e.key&&"KeyP"!=e.code||t.toggle())})}return e.prototype.assignClassesViaComments=function(){for(var e,t=document.createNodeIterator(document.body,NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_COMMENT,null),n=this.mode===PresentationMode.Web?"not-presenting":"presenting",o=null;e=t.nextNode();)if(8===e.nodeType){var s=e.nodeValue.trim();o="web-only"===s?this.webClass:"slides-only"===s?this.preClass:null}else 1===e.nodeType&&null!==o&&e.classList.add(o,n)},e.prototype.getMode=function(){var t=localStorage.getItem(this.queryKey);if(null===t)return PresentationMode.Web;try{var e=parseInt(t);return 1<e||e<0?(console.error("presentation_mode was out of range",e),PresentationMode.Web):e}catch(e){return console.error("presentation_mode present in localStorage but value is not an integer",t,e),PresentationMode.Web}},e.prototype.setMode=function(){localStorage.setItem(this.queryKey,this.mode.toString())},e.prototype.updatePage=function(){this.updateElements(document.querySelectorAll(".presentation-only")),this.updateElements(document.querySelectorAll(".article-content"))},e.prototype.updateElements=function(e){for(var t=0;t<e.length;t++){var n=e[t];this.mode===PresentationMode.Slides?n.classList.replace("not-presenting","presenting"):n.classList.replace("presenting","not-presenting")}},e.prototype.toggle=function(){switch(this.mode){case PresentationMode.Slides:this.mode=PresentationMode.Web;break;case PresentationMode.Web:this.mode=PresentationMode.Slides}this.setMode(),this.updatePage()},e}(),___presentationModeHider=new PresentationModeHider;</script><style>.presentation-only.not-presenting{display:none}.article-content.presenting{display:none}
</style>
<a class="header" href="#stringwriter" id="stringwriter"><h1>StringWriter</h1></a>
<p>When building <code>resw</code> it became clear that the only way to validate the output would be to write a bunch of files to disk and then read them back which didn't seem like the correct option. Because of this <code>resw</code> includes an public module called <code>write_str</code>. In it you will find two structs <code>WriteString</code> and <code>ChildWriter</code>. The basic idea here is that you can use this to simply write the values to a buffer that the <code>resw::Writer</code> hasn't taken ownership over and then read them back after the <code>Writer</code> is done. Below is an example of how you might use that.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn test_round_trip() {
    let original = &quot;let x = 0&quot;;
    let dest = WriteString::new();
    let parser = ressa::Parser::new(original).expect(&quot;Failed to create parser&quot;);
    let writer = resw::Writer::new(dest.generate_child());
    for part in parser {
        let part = part.expect(&quot;failed to parse part&quot;);
        writer.write_part(part).expect(&quot;failed to write part&quot;);
    }
    assert_eq!(dest.get_string_lossy(), original.to_string());
}
#}</code></pre></pre>
<script>var PresentationMode;!function(e){e[e.Slides=0]="Slides",e[e.Web=1]="Web"}(PresentationMode||(PresentationMode={}));var PresentationModeHider=function(){function e(){var t=this;(this.queryKey="presentation_mode",this.webClass="article-content",this.preClass="presentation-only",this.mode=this.getMode(),this.setMode(),this.assignClassesViaComments(),this.mode!==PresentationMode.Slides||""!==location.pathname&&"/"!==location.pathname)||document.querySelector(".sidebar > .chapter").firstChild.firstChild.click();window.addEventListener("keyup",function(e){e.altKey&&("p"!=e.key&&"P"!=e.key&&"KeyP"!=e.code||t.toggle())})}return e.prototype.assignClassesViaComments=function(){for(var e,t=document.createNodeIterator(document.body,NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_COMMENT,null),n=this.mode===PresentationMode.Web?"not-presenting":"presenting",o=null;e=t.nextNode();)if(8===e.nodeType){var s=e.nodeValue.trim();o="web-only"===s?this.webClass:"slides-only"===s?this.preClass:null}else 1===e.nodeType&&null!==o&&e.classList.add(o,n)},e.prototype.getMode=function(){var t=localStorage.getItem(this.queryKey);if(null===t)return PresentationMode.Web;try{var e=parseInt(t);return 1<e||e<0?(console.error("presentation_mode was out of range",e),PresentationMode.Web):e}catch(e){return console.error("presentation_mode present in localStorage but value is not an integer",t,e),PresentationMode.Web}},e.prototype.setMode=function(){localStorage.setItem(this.queryKey,this.mode.toString())},e.prototype.updatePage=function(){this.updateElements(document.querySelectorAll(".presentation-only")),this.updateElements(document.querySelectorAll(".article-content"))},e.prototype.updateElements=function(e){for(var t=0;t<e.length;t++){var n=e[t];this.mode===PresentationMode.Slides?n.classList.replace("not-presenting","presenting"):n.classList.replace("presenting","not-presenting")}},e.prototype.toggle=function(){switch(this.mode){case PresentationMode.Slides:this.mode=PresentationMode.Web;break;case PresentationMode.Web:this.mode=PresentationMode.Slides}this.setMode(),this.updatePage()},e}(),___presentationModeHider=new PresentationModeHider;</script><style>.presentation-only.not-presenting{display:none}.article-content.presenting{display:none}
</style>
<a class="header" href="#projects" id="projects"><h1>Projects</h1></a>
<table><thead><tr><th> name           </th><th> description                                                                                       </th><th> website                                              </th></tr></thead><tbody>
<tr><td> console_logger </td><td> A utility that will insert <code>console.log</code> to the top of all of your function bodies                </td><td> <a href="https://github.com/freemasen/rusty-ecma-book">repo</a> </td></tr>
<tr><td> lint-ie8       </td><td> A utility that will check for any javascript that would fail when executed by Internet Explorer 8 </td><td> <a href="https://github.com/freemasen/rusty-ecma-book">repo</a> </td></tr>
</tbody></table>
<script>var PresentationMode;!function(e){e[e.Slides=0]="Slides",e[e.Web=1]="Web"}(PresentationMode||(PresentationMode={}));var PresentationModeHider=function(){function e(){var t=this;(this.queryKey="presentation_mode",this.webClass="article-content",this.preClass="presentation-only",this.mode=this.getMode(),this.setMode(),this.assignClassesViaComments(),this.mode!==PresentationMode.Slides||""!==location.pathname&&"/"!==location.pathname)||document.querySelector(".sidebar > .chapter").firstChild.firstChild.click();window.addEventListener("keyup",function(e){e.altKey&&("p"!=e.key&&"P"!=e.key&&"KeyP"!=e.code||t.toggle())})}return e.prototype.assignClassesViaComments=function(){for(var e,t=document.createNodeIterator(document.body,NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_COMMENT,null),n=this.mode===PresentationMode.Web?"not-presenting":"presenting",o=null;e=t.nextNode();)if(8===e.nodeType){var s=e.nodeValue.trim();o="web-only"===s?this.webClass:"slides-only"===s?this.preClass:null}else 1===e.nodeType&&null!==o&&e.classList.add(o,n)},e.prototype.getMode=function(){var t=localStorage.getItem(this.queryKey);if(null===t)return PresentationMode.Web;try{var e=parseInt(t);return 1<e||e<0?(console.error("presentation_mode was out of range",e),PresentationMode.Web):e}catch(e){return console.error("presentation_mode present in localStorage but value is not an integer",t,e),PresentationMode.Web}},e.prototype.setMode=function(){localStorage.setItem(this.queryKey,this.mode.toString())},e.prototype.updatePage=function(){this.updateElements(document.querySelectorAll(".presentation-only")),this.updateElements(document.querySelectorAll(".article-content"))},e.prototype.updateElements=function(e){for(var t=0;t<e.length;t++){var n=e[t];this.mode===PresentationMode.Slides?n.classList.replace("not-presenting","presenting"):n.classList.replace("presenting","not-presenting")}},e.prototype.toggle=function(){switch(this.mode){case PresentationMode.Slides:this.mode=PresentationMode.Web;break;case PresentationMode.Web:this.mode=PresentationMode.Slides}this.setMode(),this.updatePage()},e}(),___presentationModeHider=new PresentationModeHider;</script>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
